From fc77ab6191a9c9f3a3a074908e7408c6e63e4ef9 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Fri, 27 Dec 2013 16:02:02 -0600
Subject: [PATCH] wip: add capemgr from 3.8

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 drivers/misc/Makefile                             |    1 +
 drivers/misc/cape/Kconfig                         |    5 +
 drivers/misc/cape/Makefile                        |    5 +
 drivers/misc/cape/beaglebone/Kconfig              |   47 +
 drivers/misc/cape/beaglebone/Makefile             |   11 +
 drivers/misc/cape/beaglebone/bone-iio-helper.c    |  243 +++
 drivers/misc/cape/beaglebone/bone-pinmux-helper.c |  206 ++
 drivers/misc/cape/beaglebone/cape-bone-argus.c    |  412 ++++
 drivers/misc/cape/beaglebone/cape-bone-geiger.c   |  500 +++++
 drivers/misc/cape/beaglebone/cape-bone-nixie.c    |  401 ++++
 drivers/misc/cape/beaglebone/capemgr.c            | 2212 +++++++++++++++++++++
 11 files changed, 4043 insertions(+)
 create mode 100644 drivers/misc/cape/Kconfig
 create mode 100644 drivers/misc/cape/Makefile
 create mode 100644 drivers/misc/cape/beaglebone/Kconfig
 create mode 100644 drivers/misc/cape/beaglebone/Makefile
 create mode 100644 drivers/misc/cape/beaglebone/bone-iio-helper.c
 create mode 100644 drivers/misc/cape/beaglebone/bone-pinmux-helper.c
 create mode 100644 drivers/misc/cape/beaglebone/cape-bone-argus.c
 create mode 100644 drivers/misc/cape/beaglebone/cape-bone-geiger.c
 create mode 100644 drivers/misc/cape/beaglebone/cape-bone-nixie.c
 create mode 100644 drivers/misc/cape/beaglebone/capemgr.c

diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index f45473e..933f83b 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -53,3 +53,4 @@ obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
 obj-y				+= mic/
+obj-y				+= cape/
diff --git a/drivers/misc/cape/Kconfig b/drivers/misc/cape/Kconfig
new file mode 100644
index 0000000..a2ef85e
--- /dev/null
+++ b/drivers/misc/cape/Kconfig
@@ -0,0 +1,5 @@
+#
+# Capes
+#
+
+source "drivers/misc/cape/beaglebone/Kconfig"
diff --git a/drivers/misc/cape/Makefile b/drivers/misc/cape/Makefile
new file mode 100644
index 0000000..7c4eb96
--- /dev/null
+++ b/drivers/misc/cape/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for cape like devices
+#
+
+obj-y				+= beaglebone/
diff --git a/drivers/misc/cape/beaglebone/Kconfig b/drivers/misc/cape/beaglebone/Kconfig
new file mode 100644
index 0000000..ae58216
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/Kconfig
@@ -0,0 +1,47 @@
+#
+# Beaglebone capes
+#
+
+config BEAGLEBONE_PINMUX_HELPER
+	tristate "Beaglebone Pinmux Helper"
+	depends on ARCH_OMAP2PLUS && OF
+	default n
+	help
+	  Say Y here to include support for the pinmux helper
+
+config BEAGLEBONE_IIO_HELPER
+	tristate "Beaglebone AM335x TSCADC Helper"
+	depends on ARCH_OMAP2PLUS && OF && MFD_TI_AM335X_TSCADC
+	default n
+	help
+	  Say Y here to include support for the IIO helper
+
+config CAPE_BEAGLEBONE
+	tristate "Beaglebone cape support"
+	depends on ARCH_OMAP2PLUS && OF && I2C
+	default n
+	select OF_PLUGIN
+	help
+	  Say Y here to include support for beaglebone capes
+
+config CAPE_BEAGLEBONE_GEIGER
+	tristate "Beaglebone Geiger Cape"
+	depends on CAPE_BEAGLEBONE
+	default n
+	help
+	  Say Y here to include support for the Geiger Cape
+
+config CAPE_BEAGLEBONE_ARGUS
+	tristate "Beaglebone Argus UPS Cape"
+	depends on CAPE_BEAGLEBONE
+	default n
+	help
+	  Say Y here to include support for the Argus UPS cape
+
+
+config CAPE_BEAGLEBONE_NIXIE
+	tristate "Beaglebone Nixie Cape"
+	depends on CAPE_BEAGLEBONE
+	default n
+	help
+	  Say Y here to include support for the Nixie Cape
diff --git a/drivers/misc/cape/beaglebone/Makefile b/drivers/misc/cape/beaglebone/Makefile
new file mode 100644
index 0000000..097e25b
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for beaglebone capes
+#
+
+obj-$(CONFIG_BEAGLEBONE_PINMUX_HELPER)	+= bone-pinmux-helper.o
+obj-$(CONFIG_BEAGLEBONE_IIO_HELPER)	+= bone-iio-helper.o
+
+obj-$(CONFIG_CAPE_BEAGLEBONE)		+= capemgr.o
+obj-$(CONFIG_CAPE_BEAGLEBONE_GEIGER)	+= cape-bone-geiger.o
+obj-$(CONFIG_CAPE_BEAGLEBONE_ARGUS)	+= cape-bone-argus.o
+obj-$(CONFIG_CAPE_BEAGLEBONE_NIXIE)	+= cape-bone-nixie.o
diff --git a/drivers/misc/cape/beaglebone/bone-iio-helper.c b/drivers/misc/cape/beaglebone/bone-iio-helper.c
new file mode 100644
index 0000000..a919857
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/bone-iio-helper.c
@@ -0,0 +1,243 @@
+/*
+ * Industrial IO helper driver
+ *
+ * Copyright (C) 2013 Matt Ranostay <mranostay@gmail.com>
+ *
+ * Based on original work by
+ *  Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/math64.h>
+#include <linux/input/ti_am335x_tsc.h>
+#include <linux/platform_data/ti_am335x_adc.h>
+#include <linux/mfd/ti_am335x_tscadc.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/machine.h>
+#include <linux/iio/consumer.h>
+
+static const struct of_device_id bone_iio_helper_of_match[] = {
+	{
+		.compatible = "bone-iio-helper",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bone_iio_helper_of_match);
+
+struct iio_helper_info;
+
+struct iio_helper_chan {
+	struct iio_helper_info *info;
+	int index;
+	const char *vsense_name;
+	unsigned int vsense_scale;
+	struct iio_channel *vsense_channel;
+	struct device_attribute attr;
+	unsigned int attr_created : 1;
+};
+
+#define iio_helper_attr_to_chan(attr) \
+	container_of((attr), struct iio_helper_chan, attr)
+
+struct iio_helper_info {
+	struct platform_device *pdev;
+	int channel_count;
+	struct iio_helper_chan *channel;
+	u32 *scale;
+};
+
+static ssize_t iio_helper_show_mvolts(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct iio_helper_chan *chan = iio_helper_attr_to_chan(attr);
+	int ret, val;
+	u32 mvolts;
+
+	ret = iio_read_channel_raw(chan->vsense_channel, &val);
+	if (ret < 0)
+		return ret;
+
+	/* volts = ((1800 / 4096) * val * scale) = (1.8 * val * scale /4096) */
+	mvolts = div_u64(1800 * chan->vsense_scale * (u64)val, 4096 * 100);
+
+	return sprintf(buf, "%d\n", mvolts);
+}
+
+static int bone_iio_helper_probe(struct platform_device *pdev)
+{
+	struct iio_helper_info *info;
+	struct iio_helper_chan *chan;
+	struct device_node *pnode = pdev->dev.of_node;
+	int i, err;
+
+	/* we only support OF */
+	if (pnode == NULL) {
+		dev_err(&pdev->dev, "No platform of_node!\n");
+		return -ENODEV;
+	}
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate info\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	platform_set_drvdata(pdev, info);
+	info->pdev = pdev;
+
+	err = of_property_count_strings(pnode, "vsense-name");
+	if (err < 0) {
+		dev_err(&pdev->dev, "Failed on vsense-name string property\n");
+		goto err_no_vsense;
+	}
+	if (err == 0) {
+		dev_err(&pdev->dev, "vsense-name property is empty\n");
+		err = -EINVAL;
+		goto err_no_vsense;
+	}
+	info->channel_count = err;
+	info->channel = devm_kzalloc(&pdev->dev,
+		info->channel_count * sizeof(*info->channel), GFP_KERNEL);
+	if (info->channel == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate channel array\n");
+		err = -ENOMEM;
+		goto err_no_chan;
+	}
+
+	info->scale = devm_kzalloc(&pdev->dev,
+		info->channel_count * sizeof(*info->scale), GFP_KERNEL);
+	if (info->scale == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate scale array\n");
+		err = -ENOMEM;
+		goto err_no_scale;
+	}
+
+	err = of_property_read_u32_array(pnode, "vsense-scale", info->scale,
+			info->channel_count);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Failed to read vsense-scale array\n");
+		goto err_bad_scale;
+	}
+
+	for (i = 0; i < info->channel_count; i++) {
+
+		chan = &info->channel[i];
+
+		err = of_property_read_string_index(pnode, "vsense-name", i,
+				&chan->vsense_name);
+		if (err != 0) {
+			dev_err(&pdev->dev, "Error on vsense-name #%d\n", i);
+			goto err_bad_chan;
+		}
+
+		chan->vsense_scale = info->scale[i];
+		if (chan->vsense_scale == 0) {
+			dev_err(&pdev->dev, "vsense-sense #%d zero\n", i);
+			err = -EINVAL;
+			goto err_bad_chan;
+		}
+
+		chan->vsense_channel = iio_channel_get(NULL, chan->vsense_name);
+		if (IS_ERR(chan->vsense_channel)) {
+			dev_err(&pdev->dev, "Could not get %s analog input\n",
+						chan->vsense_name);
+			err = PTR_ERR(chan->vsense_channel);
+			chan->vsense_channel = NULL;
+			goto err_bad_chan;
+		}
+
+		chan->attr.attr.name = chan->vsense_name;
+		chan->attr.attr.mode = S_IRUGO;
+		chan->attr.show = iio_helper_show_mvolts;
+		chan->attr.store = NULL;
+
+		err = device_create_file(&pdev->dev, &chan->attr);
+		if (err != 0) {
+			dev_err(&pdev->dev, "Could not create %s attr\n",
+						chan->vsense_name);
+			goto err_bad_chan;
+		}
+		chan->attr_created = 1;
+	}
+
+	dev_info(&pdev->dev, "ready\n");
+
+	return 0;
+err_bad_chan:
+	/* cleanup possible channels allocated */
+	for (i = info->channel_count - 1; i >= 0; i--) {
+		chan = &info->channel[i];
+		if (chan->attr_created)
+			device_remove_file(&pdev->dev, &chan->attr);
+		if (chan->vsense_channel != NULL)
+			iio_channel_release(chan->vsense_channel);
+	}
+err_bad_scale:
+	/* nothing */
+err_no_scale:
+	/* nothing */
+err_no_vsense:
+	/* nothing */
+err_no_chan:
+	/* nothing */
+err_no_mem:
+	return err;
+}
+
+
+static int bone_iio_helper_remove(struct platform_device *pdev)
+{
+	struct iio_helper_info *info = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+	struct iio_helper_chan *chan;
+	int i;
+
+	for (i = info->channel_count - 1; i >= 0; i--) {
+		chan = &info->channel[i];
+		device_remove_file(&pdev->dev, &chan->attr);
+		iio_channel_release(chan->vsense_channel);
+	}
+	devm_kfree(dev, info->scale);
+	devm_kfree(dev, info->channel);
+	devm_kfree(dev, info);
+
+	return 0;
+}
+
+struct platform_driver bone_iio_helper_driver = {
+	.probe		= bone_iio_helper_probe,
+	.remove		= bone_iio_helper_remove,
+	.driver	= {
+		.name		= "bone-iio-helper",
+		.owner		= THIS_MODULE,
+		.of_match_table	= bone_iio_helper_of_match,
+	},
+};
+
+module_platform_driver(bone_iio_helper_driver);
+
+MODULE_AUTHOR("Matt Ranostay");
+MODULE_DESCRIPTION("Beaglebone IIO helper driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bone-iio-helper");
diff --git a/drivers/misc/cape/beaglebone/bone-pinmux-helper.c b/drivers/misc/cape/beaglebone/bone-pinmux-helper.c
new file mode 100644
index 0000000..5074365
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/bone-pinmux-helper.c
@@ -0,0 +1,206 @@
+/*
+ * Pinmux helper driver
+ *
+ * Copyright (C) 2013 Pantelis Antoniou <panto@antoniou-consulting.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+
+static const struct of_device_id bone_pinmux_helper_of_match[] = {
+	{
+		.compatible = "bone-pinmux-helper",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bone_pinmux_helper_of_match);
+
+struct pinmux_helper_data {
+	struct pinctrl *pinctrl;
+	char *selected_state_name;
+};
+
+static ssize_t pinmux_helper_show_state(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pinmux_helper_data *data = platform_get_drvdata(pdev);
+	const char *name;
+
+	name = data->selected_state_name;
+	if (name == NULL || strlen(name) == 0)
+		name = "none";
+	return sprintf(buf, "%s\n", name);
+}
+
+static ssize_t pinmux_helper_store_state(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct pinmux_helper_data *data = platform_get_drvdata(pdev);
+	struct pinctrl_state *state;
+	char *state_name;
+	char *s;
+	int err;
+
+	/* duplicate (as a null terminated string) */
+	state_name = kmalloc(count + 1, GFP_KERNEL);
+	if (state_name == NULL)
+		return -ENOMEM;
+	memcpy(state_name, buf, count);
+	state_name[count] = '\0';
+
+	/* and chop off newline */
+	s = strchr(state_name, '\n');
+	if (s != NULL)
+		*s = '\0';
+
+	/* try to select default state at first (if it exists) */
+	state = pinctrl_lookup_state(data->pinctrl, state_name);
+	if (!IS_ERR(state)) {
+		err = pinctrl_select_state(data->pinctrl, state);
+		if (err != 0)
+			dev_err(dev, "Failed to select state %s\n",
+					state_name);
+	} else {
+		dev_err(dev, "Failed to find state %s\n", state_name);
+		err = PTR_RET(state);
+	}
+
+	if (err == 0) {
+		kfree(data->selected_state_name);
+		data->selected_state_name = state_name;
+	}
+
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(state, S_IWUSR | S_IRUGO,
+		   pinmux_helper_show_state, pinmux_helper_store_state);
+
+static struct attribute *pinmux_helper_attributes[] = {
+	&dev_attr_state.attr,
+	NULL
+};
+
+static const struct attribute_group pinmux_helper_attr_group = {
+	.attrs = pinmux_helper_attributes,
+};
+
+static int bone_pinmux_helper_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct pinmux_helper_data *data;
+	struct pinctrl_state *state;
+	char *state_name;
+	int err;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(dev, "Failed to allocate data\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	state_name = kmalloc(strlen(PINCTRL_STATE_DEFAULT) + 1,
+			GFP_KERNEL);
+	if (state_name == NULL) {
+		dev_err(dev, "Failed to allocate state name\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	data->selected_state_name = state_name;
+	strcpy(data->selected_state_name, PINCTRL_STATE_DEFAULT);
+
+	platform_set_drvdata(pdev, data);
+
+	data->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(data->pinctrl)) {
+		dev_err(dev, "Failed to get pinctrl\n");
+		err = PTR_RET(data->pinctrl);
+		goto err_no_pinctrl;
+	}
+
+	/* try to select default state at first (if it exists) */
+	state = pinctrl_lookup_state(data->pinctrl,
+			data->selected_state_name);
+	if (!IS_ERR(state)) {
+		err = pinctrl_select_state(data->pinctrl, state);
+		if (err != 0) {
+			dev_err(dev, "Failed to select default state\n");
+			goto err_no_state;
+		}
+	} else {
+		data->selected_state_name = '\0';
+	}
+
+	/* Register sysfs hooks */
+	err = sysfs_create_group(&dev->kobj, &pinmux_helper_attr_group);
+	if (err) {
+		dev_err(dev, "Failed to create sysfs group\n");
+		goto err_no_sysfs;
+	}
+
+	return 0;
+
+err_no_sysfs:
+err_no_state:
+	devm_pinctrl_put(data->pinctrl);
+err_no_pinctrl:
+	devm_kfree(dev, data);
+err_no_mem:
+	return err;
+}
+
+static int bone_pinmux_helper_remove(struct platform_device *pdev)
+{
+	struct pinmux_helper_data *data = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+
+	sysfs_remove_group(&dev->kobj, &pinmux_helper_attr_group);
+	kfree(data->selected_state_name);
+	devm_pinctrl_put(data->pinctrl);
+	devm_kfree(dev, data);
+
+	return 0;
+}
+
+struct platform_driver bone_pinmux_helper_driver = {
+	.probe		= bone_pinmux_helper_probe,
+	.remove		= bone_pinmux_helper_remove,
+	.driver = {
+		.name		= "bone-pinmux-helper",
+		.owner		= THIS_MODULE,
+		.of_match_table	= bone_pinmux_helper_of_match,
+	},
+};
+
+module_platform_driver(bone_pinmux_helper_driver);
+
+MODULE_AUTHOR("Pantelis Antoniou");
+MODULE_DESCRIPTION("Beaglebone pinmux helper driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bone-pinmux-helper");
diff --git a/drivers/misc/cape/beaglebone/cape-bone-argus.c b/drivers/misc/cape/beaglebone/cape-bone-argus.c
new file mode 100644
index 0000000..b92f561
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/cape-bone-argus.c
@@ -0,0 +1,412 @@
+/* -*- linux-c -*- */
+
+/* Linux Kernel Module for Breakaway Systems UPS control.
+ *
+ * PUBLIC DOMAIN
+ */
+
+#include <linux/syscalls.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/reboot.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mount.h>
+#include <linux/workqueue.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of_gpio.h>
+
+/* Module to sync file systems leaving them mounted read-only,
+ * then signal the UPS that it is safe to remove
+ * power, and finally halt the processor.
+ * Also to allow kicking the watchdog from user mode.
+ */
+
+#define N_GPIOS 9		/* Total number of GPIOS used */
+
+#define REQ_GPIO_IDX 0		/* Indices got GPIOS */
+#define ACK_GPIO_IDX 1
+#define WDG_GPIO_IDX 2
+#define LED1_GREEN_IDX 3
+#define LED1_RED_IDX 4
+#define LED2_GREEN_IDX 5
+#define LED2_RED_IDX 6
+#define GEN_OUT1_IDX 7
+#define GEN_OUT2_IDX 8
+
+static struct argus_ups_info {	/* As there is only one UPS device we can make this static */
+	struct fasync_struct *async_queue; /* asynchronous readers */
+	struct platform_device *pdev;
+	struct pwm_device *pwm_dev;
+	struct gpio gpios[N_GPIOS];
+} info = {NULL, NULL, NULL, /* Some fields filled in by device tree, probe, etc. */
+     {
+	     {-1, GPIOF_IN, "Powerdown request"},
+	     {-1, GPIOF_OUT_INIT_LOW, "Powerdown acknowledge" },
+	     {-1, GPIOF_OUT_INIT_LOW, "Watchdog"},
+	     {-1, GPIOF_OUT_INIT_LOW, "LED 1 Green"},
+	     {-1, GPIOF_OUT_INIT_LOW, "LED 1 Red"},
+	     {-1, GPIOF_OUT_INIT_LOW, "LED 2 Green"},
+	     {-1, GPIOF_OUT_INIT_LOW, "LED 2 Red"},
+	     {-1, GPIOF_OUT_INIT_LOW, "General Output #1"},
+	     {-1, GPIOF_OUT_INIT_LOW, "General Output #2"}
+     },
+};
+
+
+static const struct of_device_id argus_ups_of_ids[] = {
+	{ .compatible = "argus-ups" },
+	{ }
+};
+
+static int argus_ups_major;     /* Major device number */
+
+static struct class *argus_ups_class; /* /sys/class */
+
+dev_t argus_ups_dev;            /* Device number */
+
+static struct cdev *argus_ups_cdev; /* Character device details */
+
+static void argus_ups_function(struct work_struct *ignored); /* Work function */
+
+static DECLARE_DELAYED_WORK(argus_ups_work, argus_ups_function); /* Kernel workqueue glue */
+
+static struct workqueue_struct *argus_ups_workqueue; /* Kernel workqueue */
+
+static int debug = 0;
+module_param(debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "Debug flag");
+
+static int shutdown = 1;
+module_param(shutdown, int, S_IRUGO);
+MODULE_PARM_DESC(shutdown, "Shutdown flag");
+
+static char* fs_type_names[] = {"vfat", "ext4"}; /* File system names that may need syncing. */
+
+/* Just kick watchdog */
+
+static ssize_t argus_ups_write(struct file *filp, const char __user *buf, size_t count,
+                loff_t *f_pos)
+{
+	int i;
+        if (debug >= 3) {
+            printk("Writing to watchdog - count:%d\n", count);
+        }
+	for (i = 0; i < count; i++) {
+		gpio_set_value(info.gpios[WDG_GPIO_IDX].gpio, 1); /* Set it */
+		msleep(10);                       /* Wait */
+		gpio_set_value(info.gpios[WDG_GPIO_IDX].gpio, 0); /* End clearing it */
+		msleep(10);
+	}
+	return count;                     /* Always returns what we sent, regardsless */
+}
+
+static long argus_ups_ioctl(struct file *file,
+			   unsigned int ioctl,
+			   unsigned long param)
+{
+	if (debug >= 4) {
+		printk(KERN_ERR "ioctl: %d, param: %ld\n", ioctl, param);
+	}
+	switch(ioctl) {
+	case 10001: {
+		debug = param;
+		printk("Debug set to %d\n", debug);
+		break;
+	}
+	case 10002: {
+		unsigned char value = param & 0x0F;
+		unsigned char mask = (param >> 4) & 0x0F;
+		int i;		/* Loop iterator */
+		if (mask == 0) {
+			printk(KERN_ERR "Pointless mask of zero!\n");
+		}
+		for (i = 0; i < 4; i++) { /* For all four LEDS */
+			if (mask & (1 << i)) { /* Only masked values */
+				if (value & (1 << i)) { /* On - so gpio is hi */
+					if (debug >= 4) {
+						printk("Setting %d hi, ",
+						       info.gpios[LED1_GREEN_IDX + i].gpio);
+					}
+					gpio_set_value(info.gpios[LED1_GREEN_IDX + i].gpio, 1);
+				}
+				else {	/* Off - so gpio is lo */
+					if (debug >= 4) {
+						printk("Setting %d lo, ",
+						       info.gpios[LED1_GREEN_IDX + i].gpio);
+					}
+					gpio_set_value(info.gpios[LED1_GREEN_IDX + i].gpio, 0);
+				}
+			}
+		}
+		if (debug >= 4) {
+			printk("\n");
+		}
+		break;
+	}
+	case 10003: {
+		gpio_set_value(info.gpios[GEN_OUT1_IDX].gpio, param & 1);
+		break;
+	}
+	case 10004: {
+		gpio_set_value(info.gpios[GEN_OUT2_IDX].gpio, param & 1);
+		break;
+	}
+	default:
+	{
+		printk(KERN_ERR "Invalid ioctl %d\n", ioctl);
+		return -1;
+	}
+	}
+	return 0;
+}
+
+static int argus_ups_fasync(int fd, struct file *filp, int mode)
+{
+	printk(KERN_ERR "In argus_ups_fasync() fd:%d, filp:%p, mode:%d\n", fd, filp, mode);
+	return fasync_helper(fd, filp, mode, &info.async_queue);
+}
+
+static struct file_operations argus_ups_fops = { /* Only file operation is to kick watchdog via a write */
+	.owner =    THIS_MODULE,
+	.llseek =   NULL,
+	.read =     NULL,
+	.unlocked_ioctl = argus_ups_ioctl,
+	.write =    argus_ups_write,
+	.open =     NULL,
+	.release =  NULL,
+	.fasync = argus_ups_fasync,
+};
+
+
+static void remount_sb(struct super_block *sb)
+{
+	int flags =  MS_RDONLY;
+	int result = sb->s_op->remount_fs(sb, &flags, "");
+	if (debug) {
+		printk("Processing superblock %p\n", sb);
+		printk("Remount operation returned %d\n", result);
+	}
+}
+
+
+static void argus_ups_function(struct work_struct *ignored)
+{
+	static int testdata = 0;       /* Data for test */
+	int i;                      /* Iterator */
+	testdata++;
+	if (!gpio_get_value(info.gpios[REQ_GPIO_IDX].gpio)) {
+                queue_delayed_work(argus_ups_workqueue, &argus_ups_work, HZ/100); /* Re-queue in 10mS*/
+		return;
+        }
+	printk(KERN_ERR "Request received\n");
+	if (debug) {
+		printk("Shutdown request received from UPS\n");
+	}
+	if (!shutdown) {
+		printk("Shutdown request ignored\n");
+		return;
+	}
+
+	if (debug) {
+		printk("Sending async kill SIGIO to %p\n", info.async_queue);
+	}
+	if (info.async_queue) { /* Try and tell usermode to halt system */
+		kill_fasync(&info.async_queue, SIGIO, POLL_IN);
+	}
+	gpio_set_value(info.gpios[LED1_GREEN_IDX].gpio, 0); /* Turn off green LED1 */
+	for (i = 0; i < 300; i++) { /* Toggle acknowledge at 10 Hz for 15 seconds */
+		if (debug >= 2) {
+			printk("Waiting for first shutdown request:%d\n", i);
+		}
+		gpio_set_value(info.gpios[ACK_GPIO_IDX].gpio, i & 1); /* Toggle acknowledge */
+		gpio_set_value(info.gpios[LED1_RED_IDX].gpio, i & 1); /* and LED1 red */
+		msleep(50); /* Wait in 50ms increments */
+	}
+
+	{
+		char *argv[] = { "/sbin/halt", NULL };
+		static char *envp[] = {
+			"HOME=/",
+			"TERM=linux",
+			"PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin", NULL };
+
+		call_usermodehelper( argv[0], argv, envp, UMH_WAIT_PROC );
+	}
+	for (i = 0; i < 300; i++) { /* Toggle acknowledge at 10 Hz for 15 more seconds */
+		if (debug >= 2) {
+			printk("Waiting for second shutdown request:%d\n", i);
+		}
+		gpio_set_value(info.gpios[ACK_GPIO_IDX].gpio, i & 1); /* Toggle acknowledge */
+		gpio_set_value(info.gpios[LED1_RED_IDX].gpio, i & 1); /* and LED1 red */
+		msleep(50); /* Wait in 50ms increments */
+	}
+	printk(KERN_ERR "Usermode failed to halt system\n");
+	kernel_halt();	       /* Last resort - may give some oopss */
+}
+
+
+static int argus_ups_probe(struct platform_device *pdev) /* Entry point */
+{
+	struct pinctrl *pinctrl;
+	struct device_node *pnode = pdev->dev.of_node;
+	int i;
+	int ret;
+        printk("Init UPS module - debug=%d, shutdown=%d\n",
+	       debug, shutdown);
+	platform_set_drvdata(pdev, &info);
+	info.pdev = pdev;
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		dev_warn(&pdev->dev,
+			"pins are not configured from the driver\n");
+		return -1;
+	}
+	ret = of_property_read_u32(pnode, "debug", &debug);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Unable to read debug parameter\n");
+	}
+	else {
+		printk("Debug parameter read from DT:%d\n", debug);
+	}
+
+	ret = of_property_read_u32(pnode, "shutdown", &shutdown);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Unable to read shutdown parameter\n");
+	}
+	else {
+		printk("Shutdown parameter read from DT:%d\n", shutdown);
+	}
+
+	ret = of_gpio_count(pnode);
+
+	if (ret != N_GPIOS) {
+		printk(KERN_ERR "Wrong number of gpios");
+		return -1;
+	}
+
+	for (i = 0; i < of_gpio_count(pnode); i++) {
+		ret = of_get_gpio_flags(pnode, i, NULL);
+		if (debug) {
+			printk("GPIO#%d:%d\n", i, ret);
+		}
+		if (IS_ERR_VALUE(ret)) {
+			dev_err(&pdev->dev, "unable to get GPIO %d\n", i);
+			goto err_no_gpio;
+		}
+		info.gpios[i].gpio = ret;
+	}
+
+
+        ret = alloc_chrdev_region(&argus_ups_dev, 0, 2, "argus_ups");
+        argus_ups_major = MAJOR(argus_ups_dev);
+        if (ret) {
+		printk(KERN_ERR "Error %d adding argus_ups\n", ret);
+		return -1;
+        }
+	if (debug) {
+		printk("argus_ups major: %d\n", argus_ups_major);
+	}
+        argus_ups_cdev = cdev_alloc(); /* Make this a character device */
+        argus_ups_cdev->ops = &argus_ups_fops; /* File operations */
+        argus_ups_cdev->owner = THIS_MODULE;   /* Top level device */
+        ret = cdev_add(argus_ups_cdev, argus_ups_dev, 1); /* Add it to the kernel */
+        if (ret) {
+		printk(KERN_ERR "cdev_add returned %d\n", ret);
+		unregister_chrdev_region(0, 1);
+		return -1;
+	}
+        ret = gpio_request_array(info.gpios, N_GPIOS);
+	if (ret) {
+		printk(KERN_ERR "Error %d requesting GPIOs\n", ret);
+		unregister_chrdev_region(0, 1);
+		return -1;
+        }
+
+        argus_ups_class = class_create(THIS_MODULE, "argus_ups"); /* /sys/class entry for udev */
+        if (IS_ERR(argus_ups_class)) {
+		printk(KERN_ERR "Error creating argus_ups_class\n");
+		unregister_chrdev_region(0, 1);
+		return -1;
+	}
+	device_create(argus_ups_class, NULL, MKDEV(argus_ups_major, 0), NULL, "argus_ups");
+        argus_ups_workqueue = create_singlethread_workqueue("argus_ups");
+        INIT_DELAYED_WORK(&argus_ups_work, argus_ups_function);
+        queue_delayed_work(argus_ups_workqueue, &argus_ups_work, 0); /* Start work immediately */
+
+        return 0;
+err_no_gpio:
+	return ret;
+
+}
+
+
+static void argus_ups_cleanup(void)
+{
+	printk("Module cleanup called\n");
+        while (cancel_delayed_work(&argus_ups_work) == 0) {
+		flush_workqueue(argus_ups_workqueue); /* Make sure all work is completed */
+	}
+	destroy_workqueue(argus_ups_workqueue);
+	gpio_free_array(info.gpios, N_GPIOS);
+	device_destroy(argus_ups_class, argus_ups_dev);
+	class_destroy(argus_ups_class);
+        unregister_chrdev_region(argus_ups_dev, 1);
+        cdev_del(argus_ups_cdev);
+}
+
+
+
+static int argus_ups_remove(struct platform_device *pdev)
+{
+	printk("In argus_ups_remove()\n");
+	argus_ups_cleanup();
+	printk("After cleanup\n");
+	return 0;
+}
+
+#define ARGUS_UPS_PM_OPS NULL
+
+struct platform_driver argus_ups_driver = {
+	.probe		= argus_ups_probe,
+	.remove		= argus_ups_remove,
+	.driver = {
+		.name		= "argus-ups",
+		.owner		= THIS_MODULE,
+		.pm		= ARGUS_UPS_PM_OPS,
+		.of_match_table = argus_ups_of_ids,
+	},
+};
+
+
+static int __init argus_ups_init(void)
+{
+	return platform_driver_probe(&argus_ups_driver,
+				     argus_ups_probe);
+}
+
+static void __exit argus_ups_exit(void)
+{
+	platform_driver_unregister(&argus_ups_driver);
+	printk("After driver unregister\n");
+}
+
+module_init(argus_ups_init);
+module_exit(argus_ups_exit);
+
+/*
+ * Get rid of taint message.
+ */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Lambert");	/* Who wrote this module? */
+MODULE_DESCRIPTION("Argus UPS control"); /* What does this module do */
+MODULE_ALIAS("platform:argus-ups");
+MODULE_DEVICE_TABLE(of, argus_ups_of_ids);
diff --git a/drivers/misc/cape/beaglebone/cape-bone-geiger.c b/drivers/misc/cape/beaglebone/cape-bone-geiger.c
new file mode 100644
index 0000000..fa57be0
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/cape-bone-geiger.c
@@ -0,0 +1,500 @@
+/*
+ * Driver for beaglebone Geiger cape
+ *
+ * Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/atomic.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/clkdev.h>
+#include <linux/pwm.h>
+#include <linux/math64.h>
+#include <linux/atomic.h>
+#include <linux/leds.h>
+#include <linux/input/ti_am335x_tsc.h>
+#include <linux/platform_data/ti_am335x_adc.h>
+#include <linux/mfd/ti_am335x_tscadc.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/machine.h>
+#include <linux/iio/consumer.h>
+
+/* fwd decl. */
+struct bone_geiger_info {
+	struct platform_device *pdev;
+	struct pwm_device *pwm_dev;
+	int pwm_frequency;
+	int pwm_duty_cycle;
+	int run;
+	atomic64_t counter;
+	int event_gpio;
+	int event_irq;
+	struct led_trigger *event_led;		/* event detect */
+	struct led_trigger *run_led;		/* running      */
+	unsigned long event_blink_delay;
+	struct sysfs_dirent *counter_sd;	/* notifier */
+	const char *vsense_name;
+	unsigned int vsense_scale;
+	struct iio_channel *vsense_channel;
+};
+
+static const struct of_device_id bonegeiger_of_match[] = {
+	{
+		.compatible = "bone-cape-geiger",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bonegeiger_of_match);
+
+
+#define	DEFAULT_VSENSE_SCALE	37325		/* 373.25 */
+
+static int bonegeiger_start(struct platform_device *pdev)
+{
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+	int duty, period;
+
+	if (info->run != 0)
+		return 0;
+
+	/* checks */
+	if (info->pwm_frequency < 1000 || info->pwm_frequency > 50000) {
+		dev_err(&pdev->dev, "Cowardly refusing to use a "
+				"frequency of %d\n",
+				info->pwm_frequency);
+		return -EINVAL;
+	}
+	if (info->pwm_duty_cycle > 80) {
+		dev_err(&pdev->dev, "Cowardly refusing to use a "
+				"duty cycle of %d\n",
+				info->pwm_duty_cycle);
+		return -EINVAL;
+	}
+
+	period = div_u64(1000000000LLU, info->pwm_frequency);
+	duty = (period * info->pwm_duty_cycle) / 100;
+
+	dev_info(&pdev->dev, "starting geiger tube with "
+			"duty=%duns period=%dus\n",
+			duty, period);
+
+	pwm_config(info->pwm_dev, duty, period);
+	pwm_enable(info->pwm_dev);
+
+	info->run = 1;
+	led_trigger_event(info->run_led, LED_FULL);
+
+	return 0;
+}
+
+static int bonegeiger_stop(struct platform_device *pdev)
+{
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+
+	if (info->run == 0)
+		return 0;
+
+	dev_info(&pdev->dev, "disabling geiger tube\n");
+	pwm_config(info->pwm_dev, 0, 50000);	/* 0% duty cycle, 20KHz */
+	pwm_disable(info->pwm_dev);
+
+	info->run = 0;
+	led_trigger_event(info->run_led, LED_OFF);
+
+	return 0;
+}
+
+static ssize_t bonegeiger_show_run(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", info->run);
+}
+
+static ssize_t bonegeiger_store_run(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int run, err;
+
+	if (sscanf(buf, "%i", &run) != 1)
+		return -EINVAL;
+
+	if (run)
+		err = bonegeiger_start(pdev);
+	else
+		err = bonegeiger_stop(pdev);
+
+	return err ? err : count;
+}
+
+static ssize_t bonegeiger_show_counter(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%llu\n", atomic64_read(&info->counter));
+}
+
+static ssize_t bonegeiger_store_counter(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+
+	atomic64_set(&info->counter, 0);	/* just reset */
+	return count;
+}
+
+static ssize_t bonegeiger_show_vsense(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+	int ret, val;
+	u32 mvolts;
+
+	ret = iio_read_channel_raw(info->vsense_channel, &val);
+	if (ret < 0)
+		return ret;
+
+	/* V = (1800 / 4096) * val * scale) = (1.8 * val * scale / 4096) */
+	mvolts = div_u64(1800 * info->vsense_scale * (u64)val, 4096 * 100);
+
+	return sprintf(buf, "%d\n", mvolts);
+}
+
+static DEVICE_ATTR(run, S_IRUGO | S_IWUSR,
+		bonegeiger_show_run, bonegeiger_store_run);
+static DEVICE_ATTR(counter, S_IRUGO | S_IWUSR,
+		bonegeiger_show_counter, bonegeiger_store_counter);
+static DEVICE_ATTR(vsense, S_IRUGO,
+		bonegeiger_show_vsense, NULL);
+
+static int bonegeiger_sysfs_register(struct platform_device *pdev)
+{
+	int err;
+
+	err = device_create_file(&pdev->dev, &dev_attr_run);
+	if (err != 0)
+		goto err_no_run;
+
+	err = device_create_file(&pdev->dev, &dev_attr_counter);
+	if (err != 0)
+		goto err_no_counter;
+
+	err = device_create_file(&pdev->dev, &dev_attr_vsense);
+	if (err != 0)
+		goto err_no_vsense;
+
+	return 0;
+
+err_no_vsense:
+	device_remove_file(&pdev->dev, &dev_attr_counter);
+err_no_counter:
+	device_remove_file(&pdev->dev, &dev_attr_run);
+err_no_run:
+	return err;
+}
+
+static void bonegeiger_sysfs_unregister(struct platform_device *pdev)
+{
+	device_remove_file(&pdev->dev, &dev_attr_vsense);
+	device_remove_file(&pdev->dev, &dev_attr_counter);
+	device_remove_file(&pdev->dev, &dev_attr_run);
+}
+
+static irqreturn_t bonegeiger_irq_handler(int irq, void *dev_id)
+{
+	struct platform_device *pdev = dev_id;
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+
+	atomic64_inc(&info->counter);
+
+	led_trigger_blink_oneshot(info->event_led,
+		  &info->event_blink_delay, &info->event_blink_delay, 0);
+
+	sysfs_notify_dirent(info->counter_sd);
+
+	return IRQ_HANDLED;
+}
+
+static int bonegeiger_probe(struct platform_device *pdev)
+{
+	struct bone_geiger_info *info;
+	struct pinctrl *pinctrl;
+	struct device_node *pnode = pdev->dev.of_node;
+	phandle phandle;
+	u32 val;
+	int err;
+
+	/* we only support OF */
+	if (pnode == NULL) {
+		dev_err(&pdev->dev, "No platform of_node!\n");
+		return -ENODEV;
+	}
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate info\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	platform_set_drvdata(pdev, info);
+	info->pdev = pdev;
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&pdev->dev,
+			"pins are not configured from the driver\n");
+
+	err = of_property_read_u32(pnode, "pwms", &val);
+	if (err != 0) {
+		dev_err(&pdev->dev, "unable to read pwm handle\n");
+		goto err_no_pwm;
+	}
+	phandle = val;
+
+	info->pwm_dev = of_pwm_request(pnode, NULL);
+	if (IS_ERR(info->pwm_dev)) {
+		dev_err(&pdev->dev, "unable to request PWM\n");
+		err = PTR_ERR(info->pwm_dev);
+		goto err_no_pwm;
+	}
+
+	if (of_property_read_u32(pnode, "pwm-frequency", &val) != 0) {
+		val = 20000;
+		dev_warn(&pdev->dev, "Could not read pwm-frequency property; "
+				"using default %u\n",
+				val);
+	}
+	info->pwm_frequency = val;
+
+	if (of_property_read_u32(pnode, "pwm-duty-cycle", &val) != 0) {
+		val = 60;
+		dev_warn(&pdev->dev, "Could not read pwm-duty-cycle property; "
+				"using default %u\n",
+				val);
+	}
+	info->pwm_duty_cycle = val;
+
+	info->event_gpio = of_get_gpio_flags(pnode, 0, NULL);
+	if (IS_ERR_VALUE(info->event_gpio)) {
+		dev_err(&pdev->dev, "unable to get event GPIO\n");
+		err = info->event_gpio;
+		goto err_no_gpio;
+	}
+
+	err = gpio_request_one(info->event_gpio,
+			GPIOF_DIR_IN | GPIOF_EXPORT,
+			"bone-geiger-cape-event");
+	if (err != 0) {
+		dev_err(&pdev->dev, "failed to request event GPIO\n");
+		goto err_no_gpio;
+	}
+
+	atomic64_set(&info->counter, 0);
+
+	info->event_irq = gpio_to_irq(info->event_gpio);
+	if (IS_ERR_VALUE(info->event_irq)) {
+		dev_err(&pdev->dev, "unable to get event GPIO IRQ\n");
+		err = info->event_irq;
+		goto err_no_irq;
+	}
+
+	err = request_irq(info->event_irq, bonegeiger_irq_handler,
+			IRQF_TRIGGER_RISING | IRQF_SHARED,
+			"bone-geiger-irq", pdev);
+	if (err != 0) {
+		dev_err(&pdev->dev, "unable to request irq\n");
+		goto err_no_irq;
+	}
+
+	err = bonegeiger_sysfs_register(pdev);
+	if (err != 0) {
+		dev_err(&pdev->dev, "unable to register sysfs\n");
+		goto err_no_sysfs;
+	}
+
+	info->counter_sd = sysfs_get_dirent(pdev->dev.kobj.sd, NULL, "counter");
+	if (info->counter_sd == NULL) {
+		dev_err(&pdev->dev, "unable to get dirent of counter\n");
+		err = -ENODEV;
+		goto err_no_counter_dirent;
+	}
+
+	led_trigger_register_simple("geiger-event", &info->event_led);
+	led_trigger_register_simple("geiger-run", &info->run_led);
+
+	led_trigger_event(info->run_led, LED_OFF);
+
+	/* default */
+	if (of_property_read_u32(pnode, "event-blink-delay", &val) != 0) {
+		val = 30;
+		dev_warn(&pdev->dev, "Could not read event-blink-delay "
+				"property; using default %u\n",
+					val);
+	}
+	info->event_blink_delay = val;
+
+	/* default */
+	if (of_property_read_string(pnode, "vsense-name", &info->vsense_name) != 0) {
+		info->vsense_name = "AIN5";
+		dev_warn(&pdev->dev, "Could not read vsense-name property; "
+				"using default '%s'\n",
+					info->vsense_name);
+	}
+
+	if (of_property_read_u32(pnode, "vsense-scale", &info->vsense_scale) != 0) {
+		info->vsense_scale = DEFAULT_VSENSE_SCALE;
+		dev_warn(&pdev->dev, "Could not read vsense-scale property; "
+				"using default %u\n",
+					info->vsense_scale);
+	}
+
+	if (info->vsense_scale == 0) {
+		info->vsense_scale = DEFAULT_VSENSE_SCALE;
+		dev_warn(&pdev->dev, "Invalid vsense-scale property; "
+				"using default %u\n",
+					info->vsense_scale);
+	}
+
+	info->vsense_channel = iio_channel_get(NULL, info->vsense_name);
+	if (IS_ERR(info->vsense_channel)) {
+		dev_err(&pdev->dev, "Could not get %s analog input\n",
+					info->vsense_name);
+		err = PTR_ERR(info->vsense_channel);
+		goto err_no_vsense;
+	}
+
+	dev_info(&pdev->dev, "ready\n");
+
+	err = bonegeiger_start(pdev);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Could not start geiger device\n");
+		goto err_no_start;
+	}
+
+	return 0;
+
+err_no_start:
+	iio_channel_release(info->vsense_channel);
+err_no_vsense:
+	led_trigger_unregister_simple(info->run_led);
+	led_trigger_unregister_simple(info->event_led);
+	sysfs_put(info->counter_sd);
+err_no_counter_dirent:
+	bonegeiger_sysfs_unregister(pdev);
+err_no_sysfs:
+	free_irq(info->event_irq, pdev);
+err_no_irq:
+	gpio_free(info->event_gpio);
+err_no_gpio:
+	pwm_put(info->pwm_dev);
+err_no_pwm:
+	devm_kfree(&pdev->dev, info);
+err_no_mem:
+	return err;
+}
+
+static int bonegeiger_remove(struct platform_device *pdev)
+{
+	struct bone_geiger_info *info = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "Removing geiger cape driver...\n");
+
+	bonegeiger_stop(pdev);
+
+	iio_channel_release(info->vsense_channel);
+	led_trigger_unregister_simple(info->run_led);
+	led_trigger_unregister_simple(info->event_led);
+	sysfs_put(info->counter_sd);
+	bonegeiger_sysfs_unregister(pdev);
+	free_irq(info->event_irq, pdev);
+	gpio_free(info->event_gpio);
+	pwm_put(info->pwm_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#ifdef CONFIG_PM_RUNTIME
+static int bonegeiger_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bonegeiger_info *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+
+static int bonegeiger_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bonegeiger_info *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+#endif /* CONFIG_PM_RUNTIME */
+
+static struct dev_pm_ops bonegeiger_pm_ops = {
+	SET_RUNTIME_PM_OPS(bonegeiger_runtime_suspend,
+			   bonegeiger_runtime_resume, NULL)
+};
+#define BONEGEIGER_PM_OPS (&bonegeiger_pm_ops)
+#else
+#define BONEGEIGER_PM_OPS NULL
+#endif /* CONFIG_PM */
+
+struct platform_driver bonegeiger_driver = {
+	.probe		= bonegeiger_probe,
+	.remove		= bonegeiger_remove,
+	.driver = {
+		.name		= "bone-cape-geiger",
+		.owner		= THIS_MODULE,
+		.pm		= BONEGEIGER_PM_OPS,
+		.of_match_table	= bonegeiger_of_match,
+	},
+};
+
+module_platform_driver(bonegeiger_driver);
+
+MODULE_AUTHOR("Pantelis Antoniou");
+MODULE_DESCRIPTION("Beaglebone geiger cape");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bone-cape-geiger");
diff --git a/drivers/misc/cape/beaglebone/cape-bone-nixie.c b/drivers/misc/cape/beaglebone/cape-bone-nixie.c
new file mode 100644
index 0000000..7adfdc9
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/cape-bone-nixie.c
@@ -0,0 +1,401 @@
+/*
+ * Driver for beaglebone Nixie cape
+ *
+ *  Copyright (C) 2013 Matt Ranostay <mranostay@gmail.com>
+ *
+ * Based on original work by
+ *  Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
+ *  Copyright (C) 2012 Texas Instruments Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <asm/barrier.h>
+#include <linux/pwm.h>
+#include <linux/leds.h>
+
+enum {
+	BLANK_PWM_CHAN	= 0,
+	BOOST_PWM_CHAN	= 1,
+};
+
+struct bone_nixie_info {
+	struct platform_device *pdev;
+	struct pwm_device *pwm_dev;
+	struct led_trigger *run_led;		/* running */
+
+	int pwm_frequency;
+	int pwm_duty_cycle;
+	int pwm_period;
+	int brightness;
+	int run;
+};
+
+static const struct of_device_id bonenixie_of_match[] = {
+	{
+		.compatible = "bone-cape-nixie",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bonenixie_of_match);
+
+/*
+ * XXX: PWM subsystem doesn't allow easily selecting multiple channels on
+ *	the same chip... so we hack it.. this shouldn't be here long term
+ */
+
+static void nixie_pwm_config(struct bone_nixie_info *info,
+			     int duty, int chan)
+{
+	struct pwm_device *pwm = info->pwm_dev;
+
+	duty = (info->pwm_period * duty) / 100;
+
+	pwm->hwpwm = chan;
+	pwm_config(pwm, duty, info->pwm_period);
+
+	pwm->chip->ops->enable(pwm->chip, pwm);
+}
+
+static void nixie_pwm_disable(struct pwm_device *pwm, int chan)
+{
+	pwm->hwpwm = chan;
+	pwm->chip->ops->disable(pwm->chip, pwm);
+}
+
+static int bonenixie_start(struct platform_device *pdev)
+{
+	struct bone_nixie_info *info = platform_get_drvdata(pdev);
+	int duty;
+
+	if (info->run != 0)
+		return 0;
+
+	/* checks */
+	if (info->pwm_frequency < 1000 || info->pwm_frequency > 50000) {
+		dev_err(&pdev->dev, "Cowardly refusing to use a "
+				"frequency of %d\n",
+				info->pwm_frequency);
+		return -EINVAL;
+	}
+	if (info->pwm_duty_cycle > 80) {
+		dev_err(&pdev->dev, "Cowardly refusing to use a "
+				"duty cycle of %d\n",
+				info->pwm_duty_cycle);
+		return -EINVAL;
+	}
+
+	info->pwm_period = div_u64(1000000000LLU, info->pwm_frequency);
+	duty = (info->pwm_period * info->pwm_duty_cycle) / 100;
+
+	dev_info(&pdev->dev, "starting nixie tube with "
+			" boost converter duty=%duns period=%dus"
+			" default brightness percent=%d\n",
+			duty, info->pwm_period, info->brightness);
+
+	nixie_pwm_config(info, 100 - info->brightness, BLANK_PWM_CHAN);
+	nixie_pwm_config(info, info->pwm_duty_cycle, BOOST_PWM_CHAN);
+
+	info->run = 1;
+	led_trigger_event(info->run_led, LED_FULL);
+
+	return 0;
+}
+
+static int bonenixie_stop(struct platform_device *pdev)
+{
+	struct bone_nixie_info *info = platform_get_drvdata(pdev);
+
+	if (info->run == 0)
+		return 0;
+
+	dev_info(&pdev->dev, "disabling nixie tube\n");
+
+	nixie_pwm_config(info, 0, BLANK_PWM_CHAN);	/* 0% duty cycle */
+	nixie_pwm_disable(info->pwm_dev, BLANK_PWM_CHAN);
+
+	nixie_pwm_config(info, 0, BOOST_PWM_CHAN);	/* 0% duty cycle */
+	nixie_pwm_disable(info->pwm_dev, BOOST_PWM_CHAN);
+
+	info->run = 0;
+	led_trigger_event(info->run_led, LED_OFF);
+
+	return 0;
+}
+
+static ssize_t bonenixie_show_brightness(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_nixie_info *info = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", info->brightness);
+}
+
+
+static ssize_t bonenixie_store_brightness(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_nixie_info *info = platform_get_drvdata(pdev);
+	int brightness;
+
+	if (sscanf(buf, "%d", &brightness) != 1)
+		return -EINVAL;
+
+	if (brightness < 0 || brightness > 100)
+		return -EINVAL;
+
+	info->brightness = brightness;
+	nixie_pwm_config(info, 100 - brightness, BLANK_PWM_CHAN);
+
+	return count;
+}
+
+
+static ssize_t bonenixie_show_run(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_nixie_info *info = platform_get_drvdata(pdev);
+
+	return sprintf(buf, "%d\n", info->run);
+}
+
+
+static ssize_t bonenixie_store_run(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int run, err;
+
+	if (sscanf(buf, "%i", &run) != 1)
+		return -EINVAL;
+
+	if (run)
+		err = bonenixie_start(pdev);
+	else
+		err = bonenixie_stop(pdev);
+
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(brightness, S_IRUGO | S_IWUSR,
+		bonenixie_show_brightness, bonenixie_store_brightness);
+
+static DEVICE_ATTR(run, S_IRUGO | S_IWUSR,
+		bonenixie_show_run, bonenixie_store_run);
+
+static int bonenixie_sysfs_register(struct platform_device *pdev)
+{
+	int err;
+
+	err = device_create_file(&pdev->dev, &dev_attr_run);
+	if (err != 0)
+		goto err_no_run;
+
+	err = device_create_file(&pdev->dev, &dev_attr_brightness);
+	if (err != 0)
+		goto err_no_brightness;
+
+	return 0;
+
+err_no_brightness:
+	device_remove_file(&pdev->dev, &dev_attr_run);
+err_no_run:
+	return err;
+}
+
+static void bonenixie_sysfs_unregister(struct platform_device *pdev)
+{
+	device_remove_file(&pdev->dev, &dev_attr_brightness);
+	device_remove_file(&pdev->dev, &dev_attr_run);
+}
+
+static int bonenixie_probe(struct platform_device *pdev)
+{
+	struct bone_nixie_info *info;
+	struct pinctrl *pinctrl;
+	struct device_node *pnode = pdev->dev.of_node;
+	phandle phandle;
+	u32 val;
+	int err;
+
+	/* we only support OF */
+	if (pnode == NULL) {
+		dev_err(&pdev->dev, "No platform of_node!\n");
+		return -ENODEV;
+	}
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate info\n");
+		err = -ENOMEM;
+		goto err_no_mem;
+	}
+	platform_set_drvdata(pdev, info);
+	info->pdev = pdev;
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&pdev->dev,
+			"pins are not configured from the driver\n");
+
+	err = of_property_read_u32(pnode, "pwms", &val);
+	if (err != 0) {
+		dev_err(&pdev->dev, "unable to read pwm handle\n");
+		goto err_no_pwm;
+	}
+	phandle = val;
+
+	info->pwm_dev = of_pwm_request(pnode, NULL);
+	if (IS_ERR(info->pwm_dev)) {
+		dev_err(&pdev->dev, "unable to request PWM\n");
+		err = PTR_ERR(info->pwm_dev);
+		goto err_no_pwm;
+	}
+
+	if (of_property_read_u32(pnode, "pwm-frequency", &val) != 0) {
+		val = 9250;
+		dev_warn(&pdev->dev, "Could not read pwm-frequency property; "
+				"using default %u\n",
+				val);
+	}
+	info->pwm_frequency = val;
+
+	if (of_property_read_u32(pnode, "pwm-duty-cycle", &val) != 0) {
+		val = 35;
+		dev_warn(&pdev->dev, "Could not read pwm-duty-cycle property; "
+				"using default %u\n",
+				val);
+	}
+	info->pwm_duty_cycle = val;
+
+	if (of_property_read_u32(pnode, "default-brightness", &val) != 0) {
+		val = 80;
+		dev_warn(&pdev->dev, "Could not read default-brightness property; "
+				"using default %u\n",
+				val);
+	}
+	info->brightness = val;
+
+	err = bonenixie_sysfs_register(pdev);
+	if (err != 0) {
+		dev_err(&pdev->dev, "unable to register sysfs\n");
+		goto err_no_sysfs;
+	}
+
+	led_trigger_register_simple("nixie-run", &info->run_led);
+	led_trigger_event(info->run_led, LED_OFF);
+
+	dev_info(&pdev->dev, "ready\n");
+
+	err = bonenixie_start(pdev);
+	if (err != 0) {
+		dev_err(&pdev->dev, "Could not start nixie device\n");
+		goto err_no_start;
+	}
+
+	return 0;
+
+err_no_start:
+	led_trigger_unregister_simple(info->run_led);
+	bonenixie_sysfs_unregister(pdev);
+err_no_sysfs:
+	/* fall-through */
+err_no_pwm:
+	devm_kfree(&pdev->dev, info);
+err_no_mem:
+	return err;
+}
+
+static int bonenixie_remove(struct platform_device *pdev)
+{
+	struct bone_nixie_info *info = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "Remove nixie cape driver...\n");
+
+	bonenixie_stop(pdev);
+
+	led_trigger_unregister_simple(info->run_led);
+	bonenixie_sysfs_unregister(pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#ifdef CONFIG_PM_RUNTIME
+static int bonenixie_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_nixie_info *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+
+static int bonenixie_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_nixie_info *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+#endif /* CONFIG_PM_RUNTIME */
+
+static struct dev_pm_ops bonenixie_pm_ops = {
+	SET_RUNTIME_PM_OPS(bonenixie_runtime_suspend,
+			   bonenixie_runtime_resume, NULL)
+};
+#define BONENIXIE_PM_OPS (&bonenixie_pm_ops)
+#else
+#define BONENIXIE_PM_OPS NULL
+#endif /* CONFIG_PM */
+
+
+struct platform_driver bonenixie_driver = {
+	.probe		= bonenixie_probe,
+	.remove		= bonenixie_remove,
+	.driver = {
+		.name		= "bone-cape-nixie",
+		.owner		= THIS_MODULE,
+		.pm		= BONENIXIE_PM_OPS,
+		.of_match_table = bonenixie_of_match,
+	},
+};
+
+module_platform_driver(bonenixie_driver);
+
+MODULE_AUTHOR("Matt Ranostay");
+MODULE_DESCRIPTION("Beaglebone nixie cape");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bone-nixie-cape");
diff --git a/drivers/misc/cape/beaglebone/capemgr.c b/drivers/misc/cape/beaglebone/capemgr.c
new file mode 100644
index 0000000..13656f0
--- /dev/null
+++ b/drivers/misc/cape/beaglebone/capemgr.c
@@ -0,0 +1,2212 @@
+/*
+ * TI Beaglebone cape controller
+ *
+ * Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
+ * Copyright (C) 2012 Texas Instruments Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/of_device.h>
+#include <linux/of_fdt.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/firmware.h>
+#include <linux/err.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/memory.h>
+#include <linux/i2c.h>
+#include <linux/i2c/eeprom.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+
+/* extra command line overrides */
+static char *extra_override = NULL;
+module_param(extra_override, charp, 0444);
+MODULE_PARM_DESC(extra_override,
+		"Comma delimited list of PART-NUMBER[:REV] overrides");
+
+/* disabled capes */
+static char *disable_partno = NULL;
+module_param(disable_partno, charp, 0444);
+MODULE_PARM_DESC(disable_partno,
+		"Comma delimited list of PART-NUMBER[:REV] of disabled capes");
+
+/* enable capes */
+static char *enable_partno = NULL;
+module_param(enable_partno, charp, 0444);
+MODULE_PARM_DESC(enable_partno,
+		"Comma delimited list of PART-NUMBER[:REV] of enabled capes");
+
+
+struct bone_capemgr_info;
+
+struct slot_ee_attribute {
+	struct device_attribute devattr;
+	unsigned int field;
+	struct bone_cape_slot *slot;	/* this is filled when instantiated */
+};
+#define to_slot_ee_attribute(x) \
+	container_of((x), struct slot_ee_attribute, devattr)
+
+struct bbrd_ee_attribute {
+	struct device_attribute devattr;
+	unsigned int field;
+};
+#define to_bbrd_ee_attribute(x) \
+	container_of((x), struct bbrd_ee_attribute, devattr)
+
+struct bone_cape_slot {
+	struct list_head	node;
+	struct bone_capemgr_info *info;
+	int			slotno;
+	u32			eeprom_handle;
+	int			eeprom_addr;
+	struct i2c_client	*client;
+	struct memory_accessor	*macc;
+	unsigned int		probed : 1;
+	unsigned int		probe_failed : 1;
+	unsigned int		override : 1;
+	char			text_id[256];
+	char			signature[256];
+	/* quick access */
+	char			board_name[32+1];
+	char 			version[4+1];
+	char 			manufacturer[16+1];
+	char 			part_number[16+1];
+
+	/* attribute group */
+	char			*ee_attr_name;
+	int			ee_attrs_count;
+	struct slot_ee_attribute *ee_attrs;
+	struct attribute	**ee_attrs_tab;
+	struct attribute_group	attrgroup;
+
+	unsigned int		loading : 1;
+	unsigned int		loaded : 1;
+	char			*dtbo;
+	const struct firmware	*fw;
+	struct device_node	*overlay;
+	int			ovinfo_cnt;
+	struct of_overlay_info	*ovinfo;
+
+	/* loader thread */
+	struct task_struct	*loader_thread;
+
+	/* load priority */
+	int priority;
+};
+
+struct bone_capemap {
+	struct list_head node;
+	char *part_number;
+	struct device_node *map_node;
+};
+
+struct bone_baseboard {
+
+	/* from the matched boardmap node */
+	char			*compatible_name;
+
+	/* filled in by reading the eeprom */
+	char			signature[256];
+	char			text_id[64+1];
+
+	/* quick access */
+	char			board_name[8+1];
+	char 			revision[4+1];
+	char 			serial_number[12+1];
+
+	/* access to the eeprom */
+	u32			eeprom_handle;
+	int			eeprom_addr;
+	struct i2c_client	*client;
+	struct memory_accessor	*macc;
+	unsigned int		probed : 1;
+	unsigned int		probe_failed : 1;
+	unsigned int		override : 1;
+};
+
+struct bone_capemgr_info {
+	struct platform_device	*pdev;
+
+	atomic_t next_slot_nr;
+	struct list_head	slot_list;
+	struct mutex		slots_list_mutex;
+
+	int capemaps_nr;
+	struct list_head	capemap_list;
+	struct mutex		capemap_mutex;
+
+	/* baseboard EEPROM data */
+	struct bone_baseboard	baseboard;
+
+	/* wait queue for keeping the priorities straight */
+	wait_queue_head_t	load_wq;
+};
+
+static int bone_slot_fill_override(struct bone_cape_slot *slot,
+		struct device_node *node,
+		const char *part_number, const char *version);
+static struct bone_cape_slot *bone_capemgr_add_slot(
+		struct bone_capemgr_info *info, struct device_node *node,
+		const char *part_number, const char *version, int prio);
+static int bone_capemgr_remove_slot_no_lock(struct bone_cape_slot *slot);
+static int bone_capemgr_remove_slot(struct bone_cape_slot *slot);
+static int bone_capemgr_load(struct bone_cape_slot *slot);
+static int bone_capemgr_unload(struct bone_cape_slot *slot);
+
+/* baseboard EEPROM field definition */
+#define BBRD_EE_FIELD_HEADER		0
+#define BBRD_EE_FIELD_BOARD_NAME	1
+#define BBRD_EE_FIELD_REVISION		2
+#define BBRD_EE_FIELD_SERIAL_NUMBER	3
+#define BBRD_EE_FIELD_CONFIG_OPTION	4
+#define BBRD_EE_FILED_RSVD1		5
+#define BBRD_EE_FILED_RSVD2		6
+#define BBRD_EE_FILED_RSVD3		7
+
+/* cape EEPROM field definitions */
+#define CAPE_EE_FIELD_HEADER		0
+#define CAPE_EE_FIELD_EEPROM_REV	1
+#define CAPE_EE_FIELD_BOARD_NAME	2
+#define CAPE_EE_FIELD_VERSION		3
+#define CAPE_EE_FIELD_MANUFACTURER	4
+#define CAPE_EE_FIELD_PART_NUMBER	5
+#define CAPE_EE_FIELD_NUMBER_OF_PINS	6
+#define CAPE_EE_FIELD_SERIAL_NUMBER	7
+#define CAPE_EE_FIELD_PIN_USAGE		8
+#define CAPE_EE_FIELD_VDD_3V3EXP	9
+#define CAPE_EE_FIELD_VDD_5V		10
+#define CAPE_EE_FIELD_SYS_5V		11
+#define CAPE_EE_FIELD_DC_SUPPLIED	12
+#define CAPE_EE_FIELD_FIELDS_NR		13
+
+#define EE_FIELD_MAKE_HEADER(p)	\
+	({ \
+		const u8 *_p = (p); \
+		(((u32)_p[0] << 24) | ((u32)_p[1] << 16) | \
+		( (u32)_p[2] <<  8) |  (u32)_p[3]      ); \
+	})
+
+#define EE_FIELD_HEADER_VALID	0xaa5533ee
+
+struct ee_field {
+	const char 	*name;
+	int 		start;
+	int		size;
+	unsigned int	ascii : 1;
+	unsigned int	strip_trailing_dots : 1;
+	const char	*override;
+};
+
+/* baseboard EEPROM definitions */
+static const struct ee_field bbrd_sig_fields[] = {
+	[BBRD_EE_FIELD_HEADER] = {
+		.name		= "header",
+		.start		= 0,
+		.size		= 4,
+		.ascii		= 0,
+		.override	= "\xaa\x55\x33\xee",	/* AA 55 33 EE */
+	},
+	[BBRD_EE_FIELD_BOARD_NAME] = {
+		.name		= "board-name",
+		.start		= 4,
+		.size		= 8,
+		.ascii		= 1,
+		.strip_trailing_dots = 1,
+		.override	= "Board Name",
+	},
+	[BBRD_EE_FIELD_REVISION] = {
+		.name		= "revision",
+		.start		= 12,
+		.size		= 4,
+		.ascii		= 1,
+		.override	= "00A0",
+	},
+	[BBRD_EE_FIELD_SERIAL_NUMBER] = {
+		.name		= "serial-number",
+		.start		= 16,
+		.size		= 12,
+		.ascii		= 1,
+		.override	= "0000000000",
+	},
+	[BBRD_EE_FIELD_CONFIG_OPTION] = {
+		.name		= "config-option",
+		.start		= 28,
+		.size		= 32,
+	},
+};
+
+/* cape EEPROM definitions */
+static const struct ee_field cape_sig_fields[] = {
+	[CAPE_EE_FIELD_HEADER] = {
+		.name		= "header",
+		.start		= 0,
+		.size		= 4,
+		.ascii		= 0,
+		.override	= "\xaa\x55\x33\xee",	/* AA 55 33 EE */
+	},
+	[CAPE_EE_FIELD_EEPROM_REV] = {
+		.name		= "eeprom-format-revision",
+		.start		= 4,
+		.size		= 2,
+		.ascii		= 1,
+		.override	= "A0",
+	},
+	[CAPE_EE_FIELD_BOARD_NAME] = {
+		.name		= "board-name",
+		.start		= 6,
+		.size		= 32,
+		.ascii		= 1,
+		.strip_trailing_dots = 1,
+		.override	= "Override Board Name",
+	},
+	[CAPE_EE_FIELD_VERSION] = {
+		.name		= "version",
+		.start		= 38,
+		.size		= 4,
+		.ascii		= 1,
+		.override	= "00A0",
+	},
+	[CAPE_EE_FIELD_MANUFACTURER] = {
+		.name		= "manufacturer",
+		.start		= 42,
+		.size		= 16,
+		.ascii		= 1,
+		.strip_trailing_dots = 1,
+		.override	= "Override Manuf",
+	},
+	[CAPE_EE_FIELD_PART_NUMBER] = {
+		.name		= "part-number",
+		.start		= 58,
+		.size		= 16,
+		.ascii		= 1,
+		.strip_trailing_dots = 1,
+		.override	= "Override Part#",
+	},
+	[CAPE_EE_FIELD_NUMBER_OF_PINS] = {
+		.name		= "number-of-pins",
+		.start		= 74,
+		.size		= 2,
+		.ascii		= 0,
+		.override	= NULL,
+	},
+	[CAPE_EE_FIELD_SERIAL_NUMBER] = {
+		.name		= "serial-number",
+		.start		= 76,
+		.size		= 12,
+		.ascii		= 1,
+		.override	= "0000000000",
+	},
+	[CAPE_EE_FIELD_PIN_USAGE] = {
+		.name		= "pin-usage",
+		.start		= 88,
+		.size		= 140,
+		.ascii		= 0,
+		.override	= NULL,
+	},
+	[CAPE_EE_FIELD_VDD_3V3EXP] = {
+		.name		= "vdd-3v3exp",
+		.start		= 228,
+		.size		= 2,
+		.ascii		= 0,
+		.override	= NULL,
+	},
+	[CAPE_EE_FIELD_VDD_5V] = {
+		.name		= "vdd-5v",
+		.start		= 230,
+		.size		= 2,
+		.ascii		= 0,
+		.override	= NULL,
+	},
+	[CAPE_EE_FIELD_SYS_5V] = {
+		.name		= "sys-5v",
+		.start		= 232,
+		.size		= 2,
+		.ascii		= 0,
+		.override	= NULL,
+	},
+	[CAPE_EE_FIELD_DC_SUPPLIED] = {
+		.name		= "dc-supplied",
+		.start		= 234,
+		.size		= 2,
+		.ascii		= 0,
+		.override	= NULL,
+	},
+};
+
+static char *ee_field_get(const struct ee_field *sig_field,
+		const void *data, int field, char *buf, int bufsz)
+{
+	int len;
+
+	/* enough space? */
+	if (bufsz < sig_field->size + sig_field->ascii)
+		return NULL;
+
+	memcpy(buf, (char *)data + sig_field->start, sig_field->size);
+
+	/* terminate ascii field */
+	if (sig_field->ascii)
+		buf[sig_field->size] = '\0';;
+
+	if (sig_field->strip_trailing_dots) {
+		len = strlen(buf);
+		while (len > 1 && buf[len - 1] == '.')
+			buf[--len] = '\0';
+	}
+
+	return buf;
+}
+
+char *bbrd_ee_field_get(const void *data,
+		int field, char *buf, int bufsz)
+{
+	if ((unsigned int)field >= ARRAY_SIZE(bbrd_sig_fields))
+		return NULL;
+
+	return ee_field_get(&bbrd_sig_fields[field], data, field, buf, bufsz);
+}
+
+char *cape_ee_field_get(const void *data,
+		int field, char *buf, int bufsz)
+{
+	if ((unsigned int)field >= ARRAY_SIZE(cape_sig_fields))
+		return NULL;
+
+	return ee_field_get(&cape_sig_fields[field], data, field, buf, bufsz);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id bone_capemgr_of_match[] = {
+	{
+		.compatible = "ti,bone-capemgr",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bone_capemgr_of_match);
+
+#endif
+
+static int bone_baseboard_scan(struct bone_baseboard *bbrd)
+{
+	struct bone_capemgr_info *info = container_of(bbrd,
+			struct bone_capemgr_info, baseboard);
+	struct memory_accessor *macc = bbrd->macc;
+	const u8 *p;
+	int i, r;
+
+	/* need to read EEPROM? */
+	if (bbrd->probed)
+		goto bbrd_fail_check;
+
+	bbrd->probed = 1;
+
+	if (!bbrd->override) {
+
+		if (macc == NULL || macc->read == NULL) {
+			dev_err(&info->pdev->dev,
+				"bone: No memory accessor for baseboard\n");
+			return -ENODEV;
+		}
+
+		for (i = 0; i < 10; i++) {
+
+			/* perform read */
+			r = macc->read(macc, bbrd->signature,
+					0, sizeof(bbrd->signature));
+
+			if (r == sizeof(bbrd->signature))
+				break;
+
+			dev_info(&info->pdev->dev,
+				"bone: scan failed (%d time)\n", i + 1);
+
+			msleep(500);
+		}
+
+		if (i >= 10) {
+			bbrd->probe_failed = 1;
+			return r >= 0 ? -EINVAL : r;
+		}
+
+	} else
+		dev_info(&info->pdev->dev,
+			"bone: Using override eeprom data for baseboard\n");
+
+	p = bbrd->signature;
+	if (EE_FIELD_MAKE_HEADER(p) != EE_FIELD_HEADER_VALID) {
+		dev_err(&info->pdev->dev, "bone: Invalid signature "
+			"'%08x' at baseboard\n",
+			EE_FIELD_MAKE_HEADER(p));
+		bbrd->probe_failed = 1;
+		return -ENODEV;
+	}
+
+	bbrd_ee_field_get(bbrd->signature,
+			BBRD_EE_FIELD_BOARD_NAME,
+			bbrd->board_name, sizeof(bbrd->board_name));
+	bbrd_ee_field_get(bbrd->signature,
+			BBRD_EE_FIELD_REVISION,
+			bbrd->revision, sizeof(bbrd->revision));
+	bbrd_ee_field_get(bbrd->signature,
+			BBRD_EE_FIELD_SERIAL_NUMBER,
+			bbrd->serial_number, sizeof(bbrd->serial_number));
+
+	/* board_name,version,manufacturer,part_number */
+	snprintf(bbrd->text_id, sizeof(bbrd->text_id) - 1,
+			"%s,%s,%s", bbrd->board_name, bbrd->revision,
+			bbrd->serial_number);
+
+	/* terminate always */
+	bbrd->text_id[sizeof(bbrd->text_id) - 1] = '\0';
+
+bbrd_fail_check:
+	/* bbrd has failed and we don't support hotpluging */
+	if (bbrd->probe_failed)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int bone_slot_scan(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	struct memory_accessor *macc = slot->macc;
+	const u8 *p;
+	int r;
+
+	/* need to read EEPROM? */
+	if (slot->probed)
+		goto slot_fail_check;
+
+	slot->probed = 1;
+
+	if (!slot->override) {
+
+		if (macc == NULL || macc->read == NULL) {
+			dev_err(&info->pdev->dev,
+				"bone: No memory accessor for slot %d\n",
+				slot->slotno);
+			return -ENODEV;
+		}
+
+		/* perform read */
+		r = macc->read(macc, slot->signature,
+				0, sizeof(slot->signature));
+
+		if (r != sizeof(slot->signature)) {
+			slot->probe_failed = 1;
+			return r >= 0 ? -EINVAL : r;
+		}
+	} else
+		dev_info(&info->pdev->dev,
+			"bone: Using override eeprom data at slot %d\n",
+			slot->slotno);
+
+	p = slot->signature;
+	if (EE_FIELD_MAKE_HEADER(p) != EE_FIELD_HEADER_VALID) {
+		dev_err(&info->pdev->dev, "bone: Invalid signature "
+			"'%08x' at slot %d\n",
+			EE_FIELD_MAKE_HEADER(p),
+			slot->slotno);
+		slot->probe_failed = 1;
+		return -ENODEV;
+	}
+
+	cape_ee_field_get(slot->signature,
+			CAPE_EE_FIELD_BOARD_NAME,
+			slot->board_name, sizeof(slot->board_name));
+	cape_ee_field_get(slot->signature,
+			CAPE_EE_FIELD_VERSION,
+			slot->version, sizeof(slot->version));
+	cape_ee_field_get(slot->signature,
+			CAPE_EE_FIELD_MANUFACTURER,
+			slot->manufacturer, sizeof(slot->manufacturer));
+	cape_ee_field_get(slot->signature,
+			CAPE_EE_FIELD_PART_NUMBER,
+			slot->part_number, sizeof(slot->part_number));
+
+	/* board_name,version,manufacturer,part_number */
+	snprintf(slot->text_id, sizeof(slot->text_id) - 1,
+			"%s,%s,%s,%s", slot->board_name, slot->version,
+			slot->manufacturer, slot->part_number);
+
+	/* terminate always */
+	slot->text_id[sizeof(slot->text_id) - 1] = '\0';
+
+slot_fail_check:
+	/* slot has failed and we don't support hotpluging */
+	if (slot->probe_failed)
+		return -ENODEV;
+
+	return 0;
+}
+
+/* return 0 if not matched,, 1 if matched */
+static int bone_match_cape(const char *match,
+		const char *part_number, const char *version)
+{
+	char *tmp_part_number, *tmp_version;
+	char *buf, *s, *e, *sn;
+	int found;
+
+	if (match == NULL || part_number == NULL)
+		return 0;
+
+	/* copy the argument to work on it */
+	buf = kstrdup(match, GFP_KERNEL);
+
+	/* no memory, too bad... */
+	if (buf == NULL)
+		return 0;
+
+	found = 0;
+	s = buf;
+	e = s + strlen(s);
+	while (s < e) {
+		/* find comma separator */
+		sn = strchr(s, ',');
+		if (sn != NULL)
+			*sn++ = '\0';
+		else
+			sn = e;
+		tmp_part_number = s;
+		tmp_version = strchr(tmp_part_number, ':');
+		if (tmp_version != NULL)
+			*tmp_version++ = '\0';
+		s = sn;
+
+		/* the part names must match */
+		if (strcmp(tmp_part_number, part_number) != 0)
+			continue;
+
+		/* if there's no version, match any */
+		if (version == NULL || tmp_version == NULL ||
+			strcmp(version, tmp_version) == 0) {
+			found = 1;
+			break;
+		}
+	}
+
+	kfree(buf);
+
+	return found;
+}
+
+/* check an override slot node if it's compatible */
+static int bone_is_compatible_override(struct device_node *node,
+		const char *compatible_name)
+{
+	struct property *prop;
+	const char *part_number;
+	const char *version;
+
+	/* check if the slot is compatible with the board */
+	prop = of_find_property(node, "compatible", NULL);
+
+	/* no prop, it's something that's compatible with everything */
+	if (prop == NULL)
+		return 1;
+
+	/* check if it's directly compatible with the baseboard */
+	if (of_multi_prop_cmp(prop, compatible_name) == 0)
+		return 1;
+
+	/* forced override? */
+	if (of_multi_prop_cmp(prop, "force") == 0)
+		return 1;
+
+	/* final try, check if it's specified in the kernel command line */
+	if (extra_override == NULL)
+		return 0;
+
+	/* the compatible name should have kernel-command-line in it */
+	if (of_multi_prop_cmp(prop, "kernel-command-line") != 0)
+		return 0;
+
+	/* we must have at least the part-name */
+	if (of_property_read_string(node, "part-number",
+				&part_number) != 0)
+		return 0;
+
+	/* read the version (if it exists) */
+	if (of_property_read_string(node, "version", &version) != 0)
+		version = NULL;
+
+	/* match on the extra override */
+	return bone_match_cape(extra_override, part_number, version);
+}
+
+static int bone_is_compatible_runtime_override(struct device_node *node,
+		const char *req_part_number, const char *req_version)
+{
+	struct property *prop;
+	const char *part_number;
+	const char *version;
+
+	/* only check overrides */
+	if (!of_property_read_bool(node, "ti,cape-override"))
+		return 0;
+
+	/* check if the slot is compatible with the board */
+	prop = of_find_property(node, "compatible", NULL);
+
+	/* no prop, it's something that's compatible with everything */
+	if (prop == NULL)
+		return 1;
+
+	/* the compatible name should have runtime in it */
+	if (of_multi_prop_cmp(prop, "runtime") != 0)
+		return 0;
+
+	/* we must have at least the part-name */
+	if (of_property_read_string(node, "part-number",
+				&part_number) != 0)
+		return 0;
+
+	/* read the version (if it exists) */
+	if (of_property_read_string(node, "version", &version) != 0)
+		version = NULL;
+
+	/* the part names must match */
+	if (strcmp(req_part_number, part_number) != 0)
+		return 0;
+
+	/* if any version is null, any version matches */
+	if (version == NULL || req_version == NULL)
+		return 1;
+
+	/* finally versions must match */
+	return strcmp(req_version, version) == 0;
+}
+
+
+static ssize_t slot_ee_attr_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct slot_ee_attribute *ee_attr = to_slot_ee_attribute(attr);
+	struct bone_cape_slot *slot = ee_attr->slot;
+	const struct ee_field *sig_field;
+	int i, len;
+	char *p, *s;
+	u16 val;
+
+	/* add newline for ascii fields */
+	sig_field = &cape_sig_fields[ee_attr->field];
+
+	len = sig_field->size + sig_field->ascii;
+	p = kmalloc(len, GFP_KERNEL);
+	if (p == NULL)
+		return -ENOMEM;
+
+	s = cape_ee_field_get(slot->signature, ee_attr->field, p, len);
+	if (s == NULL)
+		return -EINVAL;
+
+	/* add newline for ascii fields and return */
+	if (sig_field->ascii) {
+		len = sprintf(buf, "%s\n", s);
+		goto out;
+	}
+
+	/* case by case handling */
+	switch (ee_attr->field) {
+		case CAPE_EE_FIELD_HEADER:
+			len = sprintf(buf, "%02x %02x %02x %02x\n",
+					s[0], s[1], s[2], s[3]);
+			break;
+
+			/* 2 bytes */
+		case CAPE_EE_FIELD_NUMBER_OF_PINS:
+		case CAPE_EE_FIELD_VDD_3V3EXP:
+		case CAPE_EE_FIELD_VDD_5V:
+		case CAPE_EE_FIELD_SYS_5V:
+		case CAPE_EE_FIELD_DC_SUPPLIED:
+			/* the bone is LE */
+			val = s[0] & (s[1] << 8);
+			len = sprintf(buf, "%u\n", (unsigned int)val & 0xffff);
+			break;
+
+		case CAPE_EE_FIELD_PIN_USAGE:
+
+			len = 0;
+			for (i = 0; i < sig_field->size / 2; i++) {
+				/* the bone is LE */
+				val = s[0] & (s[1] << 8);
+				sprintf(buf, "%04x\n", val);
+				buf += 5;
+				len += 5;
+				s += 2;
+			}
+
+			break;
+
+		default:
+			*buf = '\0';
+			len = 0;
+			break;
+	}
+
+out:
+	kfree(p);
+
+	return len;
+}
+
+#define SLOT_EE_ATTR(_name, _field) \
+	{ \
+		.devattr = __ATTR(_name, 0440, slot_ee_attr_show, NULL), \
+		.field = CAPE_EE_FIELD_##_field , \
+		.slot = NULL, \
+	}
+
+static const struct slot_ee_attribute slot_ee_attrs[] = {
+	SLOT_EE_ATTR(header, HEADER),
+	SLOT_EE_ATTR(eeprom-format-revision, EEPROM_REV),
+	SLOT_EE_ATTR(board-name, BOARD_NAME),
+	SLOT_EE_ATTR(version, VERSION),
+	SLOT_EE_ATTR(manufacturer, MANUFACTURER),
+	SLOT_EE_ATTR(part-number, PART_NUMBER),
+	SLOT_EE_ATTR(number-of-pins, NUMBER_OF_PINS),
+	SLOT_EE_ATTR(serial-number, SERIAL_NUMBER),
+	SLOT_EE_ATTR(pin-usage, PIN_USAGE),
+	SLOT_EE_ATTR(vdd-3v3exp, VDD_3V3EXP),
+	SLOT_EE_ATTR(vdd-5v, VDD_5V),
+	SLOT_EE_ATTR(sys-5v, SYS_5V),
+	SLOT_EE_ATTR(dc-supplied, DC_SUPPLIED),
+};
+
+static int bone_cape_slot_sysfs_register(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	struct device *dev = &info->pdev->dev;
+	struct slot_ee_attribute *ee_attr;
+	struct attribute_group *attrgroup;
+	int i, err, sz;
+
+	slot->ee_attr_name = kasprintf(GFP_KERNEL, "slot-%d", slot->slotno);
+	if (slot->ee_attr_name == NULL) {
+		dev_err(dev, "slot #%d: Failed to allocate ee_attr_name\n",
+				slot->slotno);
+		err = -ENOMEM;
+		goto err_fail_no_ee_attr_name;
+	}
+
+	slot->ee_attrs_count = ARRAY_SIZE(slot_ee_attrs);
+
+	sz = slot->ee_attrs_count * sizeof(*slot->ee_attrs);
+	slot->ee_attrs = kmalloc(sz, GFP_KERNEL);
+	if (slot->ee_attrs == NULL) {
+		dev_err(dev, "slot #%d: Failed to allocate ee_attrs\n",
+				slot->slotno);
+		err = -ENOMEM;
+		goto err_fail_no_ee_attrs;
+	}
+
+	attrgroup = &slot->attrgroup;
+	memset(attrgroup, 0, sizeof(*attrgroup));
+	attrgroup->name = slot->ee_attr_name;
+
+	sz = sizeof(*slot->ee_attrs_tab) * (slot->ee_attrs_count + 1);
+	attrgroup->attrs = kmalloc(sz, GFP_KERNEL);
+	if (attrgroup->attrs == NULL) {
+		dev_err(dev, "slot #%d: Failed to allocate ee_attrs_tab\n",
+				slot->slotno);
+		err = -ENOMEM;
+		goto err_fail_no_ee_attrs_tab;
+	}
+	/* copy everything over */
+	memcpy(slot->ee_attrs, slot_ee_attrs, sizeof(slot_ee_attrs));
+
+	/* bind this attr to the slot */
+	for (i = 0; i < slot->ee_attrs_count; i++) {
+		ee_attr = &slot->ee_attrs[i];
+		ee_attr->slot = slot;
+		attrgroup->attrs[i] = &ee_attr->devattr.attr;
+	}
+	attrgroup->attrs[i] = NULL;
+
+	err = sysfs_create_group(&dev->kobj, attrgroup);
+	if (err != 0) {
+		dev_err(dev, "slot #%d: Failed to allocate ee_attrs_tab\n",
+				slot->slotno);
+		err = -ENOMEM;
+		goto err_fail_no_ee_attrs_group;
+	}
+
+	return 0;
+
+err_fail_no_ee_attrs_group:
+	kfree(slot->ee_attrs_tab);
+err_fail_no_ee_attrs_tab:
+	kfree(slot->ee_attrs);
+err_fail_no_ee_attrs:
+	kfree(slot->ee_attr_name);
+err_fail_no_ee_attr_name:
+	return err;
+}
+
+static void bone_cape_slot_sysfs_unregister(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	struct device *dev = &info->pdev->dev;
+
+	sysfs_remove_group(&dev->kobj, &slot->attrgroup);
+	kfree(slot->ee_attrs_tab);
+	kfree(slot->ee_attrs);
+	kfree(slot->ee_attr_name);
+}
+
+static ssize_t bbrd_ee_attr_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct bbrd_ee_attribute *ee_attr = to_bbrd_ee_attribute(attr);
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_capemgr_info *info = platform_get_drvdata(pdev);
+	struct bone_baseboard *bbrd = &info->baseboard;
+	const struct ee_field *sig_field;
+	u16 val;
+	int i, len;
+	char *p, *s;
+
+	/* add newline for ascii fields */
+	sig_field = &bbrd_sig_fields[ee_attr->field];
+
+	len = sig_field->size + sig_field->ascii;
+	p = kmalloc(len, GFP_KERNEL);
+	if (p == NULL)
+		return -ENOMEM;
+
+	s = bbrd_ee_field_get(bbrd->signature, ee_attr->field, p, len);
+	if (s == NULL)
+		return -EINVAL;
+
+	/* add newline for ascii fields and return */
+	if (sig_field->ascii) {
+		len = sprintf(buf, "%s\n", s);
+		goto out;
+	}
+
+	/* case by case handling */
+	switch (ee_attr->field) {
+		case BBRD_EE_FIELD_HEADER:
+			len = sprintf(buf, "%02x %02x %02x %02x\n",
+					s[0], s[1], s[2], s[3]);
+			break;
+
+		case BBRD_EE_FIELD_CONFIG_OPTION:
+			len = 0;
+			for (i = 0; i < sig_field->size / 2; i++) {
+				/* the bone is LE */
+				val = s[0] & (s[1] << 8);
+				sprintf(buf, "%04x\n", val);
+				buf += 5;
+				len += 5;
+				s += 2;
+			}
+			break;
+
+		default:
+			*buf = '\0';
+			len = 0;
+			break;
+	}
+
+out:
+	kfree(p);
+
+	return len;
+}
+
+#define BBRD_EE_ATTR(_name, _field) \
+	{ \
+		.devattr = __ATTR(_name, 0440, bbrd_ee_attr_show, NULL), \
+		.field = BBRD_EE_FIELD_##_field , \
+	}
+
+static struct bbrd_ee_attribute bbrd_ee_attrs[] = {
+	BBRD_EE_ATTR(header, HEADER),
+	BBRD_EE_ATTR(board-name, BOARD_NAME),
+	BBRD_EE_ATTR(revision, REVISION),
+	BBRD_EE_ATTR(serial-number, SERIAL_NUMBER),
+	BBRD_EE_ATTR(config-option, CONFIG_OPTION),
+};
+
+static struct attribute *bbrd_attrs_flat[] = {
+	&bbrd_ee_attrs[BBRD_EE_FIELD_HEADER	 	].devattr.attr,
+	&bbrd_ee_attrs[BBRD_EE_FIELD_BOARD_NAME	 	].devattr.attr,
+	&bbrd_ee_attrs[BBRD_EE_FIELD_REVISION		].devattr.attr,
+	&bbrd_ee_attrs[BBRD_EE_FIELD_SERIAL_NUMBER	].devattr.attr,
+	&bbrd_ee_attrs[BBRD_EE_FIELD_CONFIG_OPTION	].devattr.attr,
+	NULL,
+};
+
+static const struct attribute_group bbrd_attr_group = {
+	.name	= "baseboard",
+	.attrs	= bbrd_attrs_flat,
+};
+
+static ssize_t slots_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_capemgr_info *info = platform_get_drvdata(pdev);
+	struct bone_cape_slot *slot;
+	ssize_t len, sz;
+
+	mutex_lock(&info->slots_list_mutex);
+	sz = 0;
+	list_for_each_entry(slot, &info->slot_list, node) {
+
+		len = sprintf(buf, "%2d: %02x:%c%c%c%c%c %s\n",
+				slot->slotno,
+				(int)slot->client ?
+					slot->client->addr & 0x7f : 0xff,
+				slot->probed       ? 'P' : '-',
+				slot->probe_failed ? 'F' : '-',
+				slot->override     ? 'O' : '-',
+				slot->loading	   ? 'l' : '-',
+				slot->loaded	   ? 'L' : '-',
+				slot->text_id);
+
+		buf += len;
+		sz += len;
+	}
+	mutex_unlock(&info->slots_list_mutex);
+
+	return sz;
+}
+
+static ssize_t slots_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_capemgr_info *info = platform_get_drvdata(pdev);
+	struct bone_cape_slot *slot;
+	struct device_node *pnode, *node, *slots_node;
+	char *s, *part_number, *version;
+	int ret;
+	int slotno;
+
+	/* check for remove slot */
+	if (strlen(buf) > 0 && buf[0] == '-') {
+		slotno = simple_strtoul(buf + 1, NULL, 10);
+
+		/* now load each (take lock to be sure */
+		mutex_lock(&info->slots_list_mutex);
+		list_for_each_entry(slot, &info->slot_list, node) {
+			if (slotno == slot->slotno)
+				goto found;
+		}
+
+		mutex_unlock(&info->slots_list_mutex);
+		return -ENODEV;
+found:
+		ret = bone_capemgr_remove_slot_no_lock(slot);
+		mutex_unlock(&info->slots_list_mutex);
+
+		if (ret == 0)
+			dev_info(&pdev->dev, "Removed slot #%d\n", slotno);
+		else
+			dev_err(&pdev->dev, "Failed to remove slot #%d\n",
+					slotno);
+
+		return ret == 0 ? strlen(buf) : ret;
+	}
+
+	part_number = kstrdup(buf, GFP_KERNEL);
+	if (part_number == NULL)
+		return -ENOMEM;
+
+	/* remove trailing spaces dots and newlines */
+	s = part_number + strlen(part_number);
+	while (s > part_number &&
+			(isspace(s[-1]) || s[-1] == '\n' || s[-1] == '.'))
+		*--s = '\0';
+
+	version = strchr(part_number, ':');
+	if (version != NULL)
+		*version++ = '\0';
+
+	dev_info(&pdev->dev, "part_number '%s', version '%s'\n",
+			part_number, version ? version : "N/A");
+
+	pnode = pdev->dev.of_node;
+	node = NULL;
+	slot = NULL;
+	ret = 0;
+
+	/* iterate over any slots */
+	slots_node = of_get_child_by_name(pnode, "slots");
+	if (slots_node != NULL) {
+		for_each_child_of_node(slots_node, node) {
+
+			/* check if the override is compatible */
+			if (!bone_is_compatible_runtime_override(node,
+						part_number, version))
+				continue;
+
+			/* if matches the disabled ones skip */
+			if (bone_match_cape(disable_partno,
+						part_number, NULL)) {
+				dev_info(&pdev->dev,
+					"Skipping disabled cape with "
+						"part# %s\n", part_number);
+				continue;
+			}
+
+			slot = bone_capemgr_add_slot(info, node,
+					part_number, version, 0);
+			if (IS_ERR(slot)) {
+				dev_err(&pdev->dev, "Failed to add slot #%d\n",
+					atomic_read(&info->next_slot_nr) - 1);
+				ret = PTR_ERR(slot);
+				slot = NULL;
+				goto err_fail;
+			}
+			break;
+		}
+		of_node_put(node);
+		of_node_put(slots_node);
+	}
+	slots_node = NULL;
+
+	/* no specific slot found, try immediate */
+	if (!slot)
+		slot = bone_capemgr_add_slot(info, NULL,
+				part_number, version, 0);
+
+	if (IS_ERR_OR_NULL(slot)) {
+		dev_err(&pdev->dev, "Failed to add slot #%d\n",
+			atomic_read(&info->next_slot_nr) - 1);
+		ret = slot ? PTR_ERR(slot) : -ENODEV;
+		slot = NULL;
+		goto err_fail;
+	}
+
+	kfree(part_number);
+
+	ret = bone_capemgr_load(slot);
+
+	if (ret != 0)
+		bone_capemgr_remove_slot(slot);
+
+	return ret == 0 ? strlen(buf) : ret;
+err_fail:
+	of_node_put(node);
+	of_node_put(slots_node);
+	kfree(part_number);
+	return ret;
+}
+
+static DEVICE_ATTR(slots, 0644, slots_show, slots_store);
+
+static int bone_capemgr_info_sysfs_register(struct bone_capemgr_info *info)
+{
+	struct device *dev = &info->pdev->dev;
+	int ret;
+
+	ret = device_create_file(dev, &dev_attr_slots);
+	if (ret != 0)
+		goto err_fail_no_slots;
+
+	ret = sysfs_create_group(&dev->kobj, &bbrd_attr_group);
+	if (ret != 0)
+		goto err_fail_no_bbrd_grp;
+
+	return 0;
+err_fail_no_bbrd_grp:
+	device_remove_file(dev, &dev_attr_slots);
+err_fail_no_slots:
+	return ret;
+}
+
+static void bone_capemgr_info_sysfs_unregister(struct bone_capemgr_info *info)
+{
+	struct device *dev = &info->pdev->dev;
+
+	sysfs_remove_group(&dev->kobj, &bbrd_attr_group);
+	device_remove_file(dev, &dev_attr_slots);
+}
+
+/* verify the overlay */
+static int bone_capemgr_verify_overlay(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	struct device *dev = &info->pdev->dev;
+	struct bone_baseboard *bbrd = &info->baseboard;
+	struct device_node *node = slot->overlay;
+	struct property *prop;
+	struct bone_cape_slot *slotn;
+	int err, counta, countb, i, j;
+	const char *ra, *rb;
+
+	/* validate */
+	if (node == NULL) {
+		dev_err(dev, "slot #%d: No overlay "
+				"for '%s'\n",
+				slot->slotno, slot->part_number);
+		return -EINVAL;
+	}
+
+	/* check if the slot is compatible with the board */
+	prop = of_find_property(node, "compatible", NULL);
+
+	/* no compatible property? */
+	if (prop == NULL) {
+		dev_err(dev, "slot #%d: No compatible property "
+				"for '%s'\n",
+				slot->slotno, slot->part_number);
+		return -EINVAL;
+	}
+
+	/* verify that the cape is baseboard compatible */
+	if (of_multi_prop_cmp(prop, bbrd->compatible_name) != 0) {
+		dev_err(dev, "slot #%d: Incompatible with baseboard "
+				"for '%s'\n",
+				slot->slotno, slot->part_number);
+		return -EINVAL;
+	}
+
+	/* count the strings */
+	counta = of_property_count_strings(node, "exclusive-use");
+	/* no valid property, or no resources; no matter, it's OK */
+	if (counta <= 0)
+		return 0;
+
+	/* and now check if there's a resource conflict */
+	err = 0;
+	mutex_lock(&info->slots_list_mutex);
+	for (i = 0; i < counta; i++) {
+
+		ra = NULL;
+		err = of_property_read_string_index(node, "exclusive-use",
+				i, &ra);
+		if (err != 0) {
+			dev_err(dev, "slot #%d: Could not read string #%d\n",
+					slot->slotno, i);
+			break;
+		}
+
+		list_for_each_entry(slotn, &info->slot_list, node) {
+
+			/* don't check against self */
+			if (slot == slotn)
+				continue;
+
+			/* only check against loaded or loading slots */
+			if (!slotn->loaded && !slotn->loading)
+				continue;
+
+			countb = of_property_count_strings(slotn->overlay,
+					"exclusive-use");
+			/* no valid property, or resources; it's OK */
+			if (countb <= 0)
+				continue;
+
+
+			for (j = 0; j < countb; j++) {
+
+				/* count the resources */
+				rb = NULL;
+				err = of_property_read_string_index(
+					slotn->overlay, "exclusive-use",
+						j, &rb);
+				if (err != 0) {
+					/* error, but we don't care */
+					err = 0;
+					break;
+				}
+
+				/* ignore case; just in case ;) */
+				if (strcasecmp(ra, rb) == 0) {
+
+					/* resource conflict */
+					err = -EEXIST;
+					dev_err(dev, "slot #%d: %s conflict "
+						"%s (#%d:%s)\n", slot->slotno,
+						slot->part_number, ra,
+						slotn->slotno,
+						slotn->part_number);
+					goto out;
+				}
+			}
+		}
+	}
+out:
+	mutex_unlock(&info->slots_list_mutex);
+
+	return err;
+}
+
+static int bone_capemgr_load(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	struct device *dev = &info->pdev->dev;
+	struct device_node *node;
+	struct property *prop;
+	const char *dtbo;
+	int found, err;
+	struct bone_capemap *capemap;
+
+	if (slot->probe_failed)
+		return -ENODEV;
+
+	if (slot->loaded)
+		return -EAGAIN;
+
+	mutex_lock(&info->capemap_mutex);
+	found = 0;
+	list_for_each_entry(capemap, &info->capemap_list, node) {
+		if (strcmp(capemap->part_number, slot->part_number) == 0) {
+			found = 1;
+			break;
+		}
+	}
+
+	/* found? */
+	if (found) {
+		if (capemap->map_node == NULL) {
+			mutex_unlock(&info->capemap_mutex);
+			/* need to match programatically; not supported yet */
+			dev_err(dev, "slot #%d: Failed to find capemap "
+					"for '%s'\n",
+					slot->slotno, slot->part_number);
+			return -ENODEV;
+		}
+
+		/* locate first match */
+		dtbo = NULL;
+		for_each_child_of_node(capemap->map_node, node) {
+
+			/* dtbo must exist */
+			if (of_property_read_string(node, "dtbo", &dtbo) != 0)
+				continue;
+
+			/* get version property (if any) */
+			prop = of_find_property(node, "version", NULL);
+
+			/* if no version node exists, we match */
+			if (prop == NULL)
+				break;
+
+			if (of_multi_prop_cmp(prop, slot->version) == 0)
+				break;
+		}
+
+		if (node == NULL) {
+			/* can't find dtbo version node? try the default */
+			if (of_property_read_string(capemap->map_node,
+						"dtbo", &dtbo) != 0) {
+				mutex_unlock(&info->capemap_mutex);
+				dev_err(dev, "slot #%d: Failed to find dtbo "
+						"for '%s'\n",
+						slot->slotno,
+						slot->part_number);
+				return -ENODEV;
+			}
+		}
+
+		slot->dtbo = kstrdup(dtbo, GFP_KERNEL);
+		of_node_put(node);	/* handles NULL */
+	} else {
+		dev_info(dev, "slot #%d: Requesting part number/version based "
+				"'%s-%s.dtbo\n",
+				slot->slotno,
+				slot->part_number, slot->version);
+
+		/* no specific capemap node; request the part number + .dtbo*/
+		slot->dtbo = kasprintf(GFP_KERNEL, "%s-%s.dtbo",
+				slot->part_number, slot->version);
+	}
+
+	if (slot->dtbo == NULL) {
+		mutex_unlock(&info->capemap_mutex);
+		dev_err(dev, "slot #%d: Failed to get dtbo '%s'\n",
+				slot->slotno, dtbo);
+		return -ENOMEM;
+	}
+
+	dev_info(dev, "slot #%d: Requesting firmware '%s' for board-name '%s'"
+			", version '%s'\n",
+			slot->slotno,
+			slot->dtbo, slot->board_name, slot->version);
+
+	err = request_firmware(&slot->fw, slot->dtbo, dev);
+	if (err != 0) {
+		dev_err(dev, "failed to load firmware '%s'\n", slot->dtbo);
+		mutex_unlock(&info->capemap_mutex);
+		goto err_fail_no_fw;
+	}
+
+	dev_info(dev, "slot #%d: dtbo '%s' loaded; converting to live tree\n",
+			slot->slotno, slot->dtbo);
+
+	mutex_unlock(&info->capemap_mutex);
+
+	of_fdt_unflatten_tree((void *)slot->fw->data, &slot->overlay);
+	if (slot->overlay == NULL) {
+		dev_err(dev, "slot #%d: Failed to unflatten\n",
+				slot->slotno);
+		err = -EINVAL;
+		goto err_fail;
+	}
+
+	/* mark it as detached */
+	of_node_set_flag(slot->overlay, OF_DETACHED);
+
+	/* perform resolution */
+	err = of_resolve(slot->overlay);
+	if (err != 0) {
+		dev_err(dev, "slot #%d: Failed to resolve tree\n",
+				slot->slotno);
+		goto err_fail;
+	}
+
+	err = bone_capemgr_verify_overlay(slot);
+	if (err != 0) {
+		dev_err(dev, "slot #%d: Failed verification\n",
+				slot->slotno);
+		goto err_fail;
+	}
+
+	/* now build an overlay info array */
+	err = of_build_overlay_info(slot->overlay,
+			&slot->ovinfo_cnt, &slot->ovinfo);
+	if (err != 0) {
+		dev_err(dev, "slot #%d: Failed to build overlay info\n",
+				slot->slotno);
+		goto err_fail;
+	}
+
+	dev_info(dev, "slot #%d: #%d overlays\n",
+			slot->slotno, slot->ovinfo_cnt);
+
+	err = of_overlay(slot->ovinfo_cnt, slot->ovinfo);
+	if (err != 0) {
+		if (err != 0) {
+			dev_err(dev, "slot #%d: Failed to overlay\n",
+					slot->slotno);
+			goto err_fail_overlay;
+		}
+	}
+
+	dev_info(dev, "slot #%d: Applied #%d overlays.\n",
+			slot->slotno, slot->ovinfo_cnt);
+
+	slot->loading = 0;
+	slot->loaded = 1;
+
+	return 0;
+
+err_fail_overlay:
+
+	of_free_overlay_info(slot->ovinfo_cnt, slot->ovinfo);
+	slot->ovinfo_cnt = 0;
+	slot->ovinfo = NULL;
+
+err_fail:
+
+	/* we can't free the overlay, because the unflatten method is a mess */
+	/* __of_free_tree(slot->overlay); */
+	slot->overlay = NULL;
+
+	release_firmware(slot->fw);
+	slot->fw = NULL;
+
+err_fail_no_fw:
+	slot->loading = 0;
+	return err;
+}
+
+static int bone_capemgr_unload(struct bone_cape_slot *slot)
+{
+	if (!slot->loaded || slot->ovinfo == NULL)
+		return -EINVAL;
+
+	of_overlay_revert(slot->ovinfo_cnt, slot->ovinfo);
+
+	slot->ovinfo_cnt = 0;
+	kfree(slot->ovinfo);
+
+	slot->loaded = 0;
+
+	return 0;
+
+}
+
+/* slots_list_mutex must be taken */
+static int bone_capemgr_remove_slot_no_lock(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	struct device *dev = &info->pdev->dev;
+	int ret;
+
+	if (slot == NULL)
+		return 0;
+
+	if (slot->loaded && slot->ovinfo) {
+		/* unload just in case */
+		ret = bone_capemgr_unload(slot);
+		if (ret != 0) {
+			dev_err(dev, "Unable to unload slot #%d\n", slot->slotno);
+			return ret;
+		}
+	}
+
+	/* if probed OK, remove the sysfs nodes */
+	if (slot->probed && !slot->probe_failed)
+		bone_cape_slot_sysfs_unregister(slot);
+
+	/* remove it from the list */
+	list_del(&slot->node);
+
+	devm_kfree(dev, slot);
+
+	return 0;
+}
+
+static int bone_capemgr_remove_slot(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	int ret;
+
+	mutex_lock(&info->slots_list_mutex);
+	ret = bone_capemgr_remove_slot_no_lock(slot);
+	mutex_unlock(&info->slots_list_mutex);
+
+	return ret;
+}
+
+static int bone_slot_fill_override(struct bone_cape_slot *slot,
+		struct device_node *node,
+		const char *part_number, const char *version)
+{
+	const struct ee_field *sig_field;
+	struct property *prop;
+	int i, len, has_part_number;
+	u32 val;
+	char *p;
+
+	slot->probe_failed = 0;
+	slot->probed = 0;
+
+	/* zero out signature */
+	memset(slot->signature, 0,
+			sizeof(slot->signature));
+
+	/* first, fill in all with override defaults */
+	for (i = 0; i < ARRAY_SIZE(cape_sig_fields); i++) {
+
+		sig_field = &cape_sig_fields[i];
+
+		/* point to the entry */
+		p = slot->signature + sig_field->start;
+
+		if (sig_field->override)
+			memcpy(p, sig_field->override,
+					sig_field->size);
+		else
+			memset(p, 0, sig_field->size);
+	}
+
+	/* and now, fill any override data from the node */
+	has_part_number = 0;
+	if (node != NULL) {
+		for (i = 0; i < ARRAY_SIZE(cape_sig_fields); i++) {
+
+			sig_field = &cape_sig_fields[i];
+
+			/* find property with the same name (if any) */
+			prop = of_find_property(node, sig_field->name, NULL);
+			if (prop == NULL)
+				continue;
+
+			/* point to the entry */
+			p = slot->signature + sig_field->start;
+
+			/* copy and zero out any remainder */
+			len = prop->length;
+			if (prop->length > sig_field->size)
+				len = sig_field->size;
+			memcpy(p, prop->value, len);
+			if (len < sig_field->size)
+				memset(p + len, 0, sig_field->size - len);
+
+			/* remember if we got a part number which is required */
+			if (i == CAPE_EE_FIELD_PART_NUMBER && len > 0)
+				has_part_number = 1;
+		}
+
+		if (of_property_read_u32(node, "priority", &val) != 0)
+			val = 0;
+		slot->priority = val;
+	}
+
+	/* if a part_number is supplied use it */
+	if (part_number && (len = strlen(part_number)) > 0) {
+		sig_field = &cape_sig_fields[CAPE_EE_FIELD_PART_NUMBER];
+
+		/* point to the entry */
+		p = slot->signature + sig_field->start;
+
+		/* copy and zero out any remainder */
+		if (len > sig_field->size)
+			len = sig_field->size;
+		memcpy(p, part_number, len);
+		if (len < sig_field->size)
+			memset(p + len, 0, sig_field->size - len);
+
+		has_part_number = 1;
+	}
+
+	/* if a version is supplied use it */
+	if (version && (len = strlen(version)) > 0) {
+		sig_field = &cape_sig_fields[CAPE_EE_FIELD_VERSION];
+
+		/* point to the entry */
+		p = slot->signature + sig_field->start;
+
+		/* copy and zero out any remainder */
+		if (len > sig_field->size)
+			len = sig_field->size;
+		memcpy(p, version, len);
+		if (len < sig_field->size)
+			memset(p + len, 0, sig_field->size - len);
+	}
+
+	/* we must have a part number */
+	if (!has_part_number)
+		return -EINVAL;
+
+	slot->override = 1;
+
+	return 0;
+}
+
+static struct bone_cape_slot *
+bone_capemgr_add_slot(struct bone_capemgr_info *info, struct device_node *node,
+		const char *part_number, const char *version, int prio)
+{
+	struct device_node *eeprom_node;
+	struct bone_cape_slot *slot;
+	struct device *dev = &info->pdev->dev;
+	int slotno;
+	int ret;
+
+	eeprom_node = NULL;
+
+	slotno = atomic_inc_return(&info->next_slot_nr) - 1;
+
+	slot = devm_kzalloc(dev, sizeof(*slot), GFP_KERNEL);
+	if (slot == NULL) {
+		ret = -ENOMEM;
+		goto err_no_mem;
+	}
+	slot->info = info;
+	slot->slotno = slotno;
+	slot->priority = prio;
+
+	if (node && !of_property_read_bool(node, "ti,cape-override")) {
+		ret = of_property_read_u32(node, "eeprom",
+				&slot->eeprom_handle);
+		if (ret != 0) {
+			dev_err(dev, "slot #%d: failed to locate eeprom\n",
+					slotno);
+			goto err_no_eeprom;
+		}
+		eeprom_node = of_find_node_by_phandle(slot->eeprom_handle);
+		if (eeprom_node == NULL) {
+			dev_err(dev, "slot #%d: failed to find eeprom node\n",
+					slotno);
+			ret = -ENODEV;
+			goto err_no_eeprom_node;
+		}
+		slot->client = of_find_i2c_device_by_node(eeprom_node);
+		if (slot->client == NULL) {
+			dev_err(dev, "slot #%d: failed to find i2c client\n",
+					slotno);
+			ret = -ENODEV;
+			goto err_no_eeprom_client;
+		}
+		/* release ref to the node & get ref of the i2c client */
+		of_node_put(eeprom_node);
+		eeprom_node = NULL;
+		i2c_use_client(slot->client);
+
+		/* grab the memory accessor of the eeprom */
+		slot->macc = i2c_eeprom_get_memory_accessor(slot->client);
+		if (IS_ERR_OR_NULL(slot->macc)) {
+			dev_err(dev, "slot #%d: failed to get "
+					"memory accessor\n", slotno);
+			ret = slot->macc == NULL ? -ENODEV :
+				PTR_ERR(slot->macc);
+			slot->macc = NULL;
+			goto err_no_eeprom_macc;
+		}
+
+	} else {
+		if (node)
+			dev_info(dev, "slot #%d: specific override\n", slotno);
+		else
+			dev_info(dev, "slot #%d: generic override\n", slotno);
+
+		/* fill in everything with defaults first */
+		ret = bone_slot_fill_override(slot, node, part_number, version);
+		if (ret != 0) {
+			dev_err(dev, "slot #%d: override failed\n",
+					slotno);
+			goto err_no_eeprom;
+		}
+	}
+
+	ret = bone_slot_scan(slot);
+	if (ret != 0) {
+
+		if (!slot->probe_failed) {
+			dev_err(dev, "slot #%d: scan failed\n",
+					slotno);
+			goto err_bad_scan;
+		}
+
+		dev_err(dev, "slot #%d: No cape found\n",
+				slotno);
+		/* but all is fine */
+	} else {
+
+		dev_info(dev, "slot #%d: '%s'\n",
+				slotno, slot->text_id);
+
+		ret = bone_cape_slot_sysfs_register(slot);
+		if (ret != 0) {
+			dev_err(dev, "slot #%d: sysfs register failed\n",
+					slotno);
+			goto err_no_sysfs;
+		}
+
+	}
+
+	/* add to the slot list */
+	mutex_lock(&info->slots_list_mutex);
+	list_add_tail(&slot->node, &info->slot_list);
+	mutex_unlock(&info->slots_list_mutex);
+
+	return slot;
+
+err_no_sysfs:
+err_bad_scan:
+err_no_eeprom_macc:
+	i2c_release_client(slot->client);
+err_no_eeprom_client:
+	of_node_put(eeprom_node);	/* handles NULL */
+err_no_eeprom_node:
+	/* nothing */
+err_no_eeprom:
+	devm_kfree(dev, slot);
+
+err_no_mem:
+	return ERR_PTR(ret);
+}
+
+static int lowest_loading_cape(struct bone_cape_slot *slot)
+{
+	struct bone_capemgr_info *info = slot->info;
+	int my_prio = slot->priority;
+	struct device *dev = &info->pdev->dev;
+	int ret;
+
+	dev_info(dev, "loader: check slot-%d %s:%s (prio %d)\n", slot->slotno,
+			slot->part_number, slot->version, slot->priority);
+
+	mutex_lock(&info->slots_list_mutex);
+	ret = 1;
+	list_for_each_entry(slot, &info->slot_list, node) {
+		/* if any slot is loading with lowest priority */
+		if (!slot->loading)
+			continue;
+		if (slot->priority < my_prio) {
+			ret = 0;
+			break;
+		}
+	}
+	mutex_unlock(&info->slots_list_mutex);
+	return ret;
+}
+
+static int bone_capemgr_loader(void *data)
+{
+	struct bone_cape_slot *slot = data;
+	struct bone_capemgr_info *info = slot->info;
+	struct device *dev = &info->pdev->dev;
+	int ret;
+
+	dev_info(dev, "loader: before slot-%d %s:%s (prio %d)\n", slot->slotno,
+			slot->part_number, slot->version, slot->priority);
+
+	/*
+	 * We have a basic priority based arbitration system
+	 * Slots have priorities, so the lower priority ones
+	 * should start loading first. So each time we end up
+	 * here.
+	 */
+	ret = wait_event_interruptible(info->load_wq,
+			lowest_loading_cape(slot));
+	if (ret < 0) {
+		dev_info(dev, "loader, Signal pending\n");
+		return ret;
+	}
+
+	dev_info(dev, "loader: after slot-%d %s:%s (prio %d)\n", slot->slotno,
+			slot->part_number, slot->version, slot->priority);
+
+	ret = bone_capemgr_load(slot);
+
+	slot->loading = 0;
+
+	if (ret == 0)
+		dev_info(dev, "loader: done slot-%d %s:%s (prio %d)\n",
+			slot->slotno, slot->part_number, slot->version,
+			slot->priority);
+	else
+		dev_err(dev, "loader: failed to load slot-%d %s:%s (prio %d)\n",
+			slot->slotno, slot->part_number, slot->version,
+			slot->priority);
+
+	/* we're done, wake up all */
+	wake_up_interruptible_all(&info->load_wq);
+
+	/* not loaded? remove */
+	if (ret != 0)
+		bone_capemgr_remove_slot(slot);
+
+	return ret;
+}
+
+static int
+bone_capemgr_probe(struct platform_device *pdev)
+{
+	struct bone_capemgr_info *info;
+	struct bone_baseboard *bbrd;
+	struct bone_cape_slot *slot;
+	struct device_node *pnode = pdev->dev.of_node;
+	struct device_node *baseboardmaps_node;
+	struct device_node *slots_node, *capemaps_node, *node;
+	struct device_node *eeprom_node;
+	const char *part_number;
+	const char *version;
+	const char *board_name;
+	const char *compatible_name;
+	struct bone_capemap *capemap;
+	int ret, len, prio;
+	long val;
+	char *wbuf, *s, *p, *e;
+
+	/* we don't use platform_data at all; we require OF */
+	if (pnode == NULL)
+		return -ENOTSUPP;
+
+	info = devm_kzalloc(&pdev->dev,
+			sizeof(struct bone_capemgr_info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&pdev->dev, "Failed to allocate device structure\n");
+		return -ENOMEM;
+	}
+
+	info->pdev = pdev;
+	platform_set_drvdata(pdev, info);
+
+	atomic_set(&info->next_slot_nr, 0);
+	INIT_LIST_HEAD(&info->slot_list);
+	mutex_init(&info->slots_list_mutex);
+
+	INIT_LIST_HEAD(&info->capemap_list);
+	mutex_init(&info->capemap_mutex);
+
+	init_waitqueue_head(&info->load_wq);
+
+	baseboardmaps_node = NULL;
+	capemaps_node = NULL;
+
+	/* find the baseboard */
+	bbrd = &info->baseboard;
+
+	baseboardmaps_node = of_get_child_by_name(pnode, "baseboardmaps");
+	if (baseboardmaps_node == NULL) {
+		dev_err(&pdev->dev, "Failed to get baseboardmaps node");
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	/* get eeprom of the baseboard */
+	ret = of_property_read_u32(pnode, "eeprom",
+			&bbrd->eeprom_handle);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to locate baseboard eeprom\n");
+		goto err_exit;
+	}
+	eeprom_node = of_find_node_by_phandle(bbrd->eeprom_handle);
+	if (eeprom_node == NULL) {
+		dev_err(&pdev->dev, "Failed to find baseboard eeprom node\n");
+		ret = -ENODEV;
+		goto err_exit;
+	}
+	bbrd->client = of_find_i2c_device_by_node(eeprom_node);
+	of_node_put(eeprom_node);
+	eeprom_node = NULL;
+	if (bbrd->client == NULL) {
+		dev_err(&pdev->dev, "Failed to find baseboard i2c client\n");
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+	/* release ref to the node & get ref of the i2c client */
+	i2c_use_client(bbrd->client);
+
+	/* grab the memory accessor of the eeprom */
+	bbrd->macc = i2c_eeprom_get_memory_accessor(bbrd->client);
+	if (IS_ERR_OR_NULL(bbrd->macc)) {
+		dev_err(&pdev->dev, "Failed to get "
+				"baseboard memory accessor\n");
+		ret = bbrd->macc == NULL ? -ENODEV :
+			PTR_ERR(bbrd->macc);
+		bbrd->macc = NULL;
+		goto err_exit;
+	}
+
+	ret = bone_baseboard_scan(bbrd);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to scan baseboard eeprom\n");
+		goto err_exit;
+	}
+
+	dev_info(&pdev->dev, "Baseboard: '%s'\n", bbrd->text_id);
+
+	board_name = NULL;
+	compatible_name = NULL;
+	for_each_child_of_node(baseboardmaps_node, node) {
+		/* there must be board-name */
+		if (of_property_read_string(node, "board-name",
+					&board_name) != 0 ||
+		    of_property_read_string(node, "compatible-name",
+					&compatible_name) != 0)
+			continue;
+
+		if (strcmp(bbrd->board_name, board_name) == 0)
+			break;
+	}
+	of_node_put(baseboardmaps_node);
+	baseboardmaps_node = NULL;
+
+	if (node == NULL) {
+		dev_err(&pdev->dev, "Failed to find compatible map for %s\n",
+				bbrd->board_name);
+		ret = -ENODEV;
+		goto err_exit;
+	}
+	bbrd->compatible_name = kstrdup(compatible_name, GFP_KERNEL);
+	if (bbrd->compatible_name == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate compatible name\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+	of_node_put(node);
+
+	dev_info(&pdev->dev, "compatible-baseboard=%s\n",
+			bbrd->compatible_name);
+
+	/* iterate over any capemaps */
+	capemaps_node = of_get_child_by_name(pnode, "capemaps");
+	if (capemaps_node != NULL) {
+
+		for_each_child_of_node(capemaps_node, node) {
+
+			/* there must be part-number */
+			if (of_property_read_string(node, "part-number",
+						&part_number) != 0)
+				continue;
+
+			/* if matches the disabled ones skip */
+			if (bone_match_cape(disable_partno,
+						part_number, NULL)) {
+				dev_info(&pdev->dev,
+					"Skipping disabled cape with "
+						"part# %s\n", part_number);
+				continue;
+			}
+
+			len = sizeof(*capemap) + strlen(part_number) + 1;
+			capemap = devm_kzalloc(&pdev->dev, len, GFP_KERNEL);
+			if (capemap == NULL) {
+				dev_err(&pdev->dev, "Failed to allocate "
+						"capemap\n");
+				ret = -ENOMEM;
+				goto err_exit;
+			}
+			capemap->part_number = (char *)(capemap + 1);
+			capemap->map_node = of_node_get(node);
+			strcpy(capemap->part_number, part_number);
+
+			/* add to the slot list */
+			mutex_lock(&info->capemap_mutex);
+			list_add_tail(&capemap->node, &info->capemap_list);
+			info->capemaps_nr++;
+			mutex_unlock(&info->capemap_mutex);
+		}
+		of_node_put(capemaps_node);
+		capemaps_node = NULL;
+	}
+
+	/* iterate over any slots */
+	slots_node = of_get_child_by_name(pnode, "slots");
+	if (slots_node != NULL) {
+		for_each_child_of_node(slots_node, node) {
+
+			/* check if the override is compatible */
+			if (!bone_is_compatible_override(node,
+						bbrd->compatible_name))
+				continue;
+
+			slot = bone_capemgr_add_slot(info, node,
+					NULL, NULL, 0);
+			if (IS_ERR(slot)) {
+				dev_err(&pdev->dev, "Failed to add slot #%d\n",
+					atomic_read(&info->next_slot_nr));
+				ret = PTR_ERR(slot);
+				goto err_exit;
+			}
+			/* note that slot may be NULL (means it was disabled) */
+		}
+		of_node_put(slots_node);
+	}
+	slots_node = NULL;
+
+	/* iterate over enable_partno (if there) */
+	if (enable_partno && strlen(enable_partno) > 0) {
+
+		/* allocate a temporary buffer */
+		wbuf = devm_kzalloc(&pdev->dev, PAGE_SIZE, GFP_KERNEL);
+		if (wbuf == NULL) {
+			dev_err(&pdev->dev, "Failed to allocate temporary buffer\n");
+			ret = -ENOMEM;
+			goto err_exit;
+		}
+
+		/* add any enable_partno capes */
+		s = enable_partno;
+		while (*s) {
+			/* form is PART[:REV[:PRIO]],PART.. */
+			p = strchr(s, ',');
+			if (p == NULL)
+				e = s + strlen(s);
+			else
+				e = p;
+
+			/* copy to temp buffer */
+			len = e - s;
+			if (len >= PAGE_SIZE - 1)
+				len = PAGE_SIZE - 1;
+			memcpy(wbuf, s, len);
+			wbuf[len] = '\0';
+
+			/* move to the next */
+			s = *e ? e + 1 : e;
+
+			part_number = wbuf;
+
+			/* default version is NULL & prio is 0 */
+			version = NULL;
+			prio = 0;
+
+			/* now split the rev & prio part */
+			p = strchr(wbuf, ':');
+			if (p != NULL) {
+				*p++ = '\0';
+				if (*p != ':')
+					version = p;
+				p = strchr(p, ':');
+				if (p != NULL) {
+					*p++ = '\0';
+					ret = kstrtol(p, 10, &val);
+					if (ret == 0)
+						prio = val;
+				}
+			}
+
+
+			dev_info(&pdev->dev, "enabled_partno part_number '%s', version '%s', prio '%d'\n",
+					part_number, version ? version : "N/A", prio);
+
+			/* only immediate slots are allowed here */
+			slot = bone_capemgr_add_slot(info, NULL,
+					part_number, version, prio);
+
+			/* we continue even in case of an error */
+			if (IS_ERR_OR_NULL(slot)) {
+				dev_warn(&pdev->dev, "Failed to add slot #%d\n",
+					atomic_read(&info->next_slot_nr) - 1);
+			}
+		}
+
+		devm_kfree(&pdev->dev, wbuf);
+	}
+
+	pm_runtime_enable(&pdev->dev);
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (IS_ERR_VALUE(ret)) {
+		dev_err(&pdev->dev, "Failed to pm_runtime_get_sync()\n");
+		goto err_exit;
+	}
+
+	pm_runtime_put(&pdev->dev);
+
+	bone_capemgr_info_sysfs_register(info);
+
+	/* now load each (take lock to be sure */
+	mutex_lock(&info->slots_list_mutex);
+
+	list_for_each_entry(slot, &info->slot_list, node) {
+
+		/* if matches the disabled ones skip */
+		if (bone_match_cape(disable_partno,
+					slot->part_number, NULL)) {
+			dev_info(&pdev->dev,
+				"Skipping loading of disabled cape with "
+					"part# %s\n", slot->part_number);
+			continue;
+		}
+
+		if (!slot->probe_failed && !slot->loaded)
+			slot->loading = 1;
+	}
+
+	/* now start the loader thread(s) (all at once) */
+	list_for_each_entry(slot, &info->slot_list, node) {
+
+		if (!slot->loading)
+			continue;
+
+		slot->loader_thread = kthread_run(bone_capemgr_loader,
+				slot, "capemgr-loader-%d",
+				slot->slotno);
+		if (IS_ERR(slot->loader_thread)) {
+			dev_warn(&pdev->dev, "slot #%d: Failed to "
+					"start loader\n", slot->slotno);
+			slot->loader_thread = NULL;
+		}
+	}
+	mutex_unlock(&info->slots_list_mutex);
+
+	dev_info(&pdev->dev, "initialized OK.\n");
+
+	return 0;
+
+err_exit:
+	of_node_put(baseboardmaps_node);
+	of_node_put(capemaps_node);
+	platform_set_drvdata(pdev, NULL);
+	devm_kfree(&pdev->dev, info);
+
+	return ret;
+}
+
+static int bone_capemgr_remove(struct platform_device *pdev)
+{
+	struct bone_capemgr_info *info = platform_get_drvdata(pdev);
+	struct bone_cape_slot *slot, *slotn;
+	int ret;
+
+	mutex_lock(&info->slots_list_mutex);
+	list_for_each_entry_safe(slot, slotn, &info->slot_list, node)
+		bone_capemgr_remove_slot_no_lock(slot);
+	mutex_unlock(&info->slots_list_mutex);
+
+	bone_capemgr_info_sysfs_unregister(info);
+
+	platform_set_drvdata(pdev, NULL);
+
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (IS_ERR_VALUE(ret))
+		return ret;
+
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	devm_kfree(&pdev->dev, info);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#ifdef CONFIG_PM_RUNTIME
+static int bone_capemgr_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_capemgr_info *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+
+static int bone_capemgr_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_capemgr_info *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+#endif /* CONFIG_PM_RUNTIME */
+
+static struct dev_pm_ops bone_capemgr_pm_ops = {
+	SET_RUNTIME_PM_OPS(bone_capemgr_runtime_suspend,
+			   bone_capemgr_runtime_resume, NULL)
+};
+#define BONE_CAPEMGR_PM_OPS (&bone_capemgr_pm_ops)
+#else
+#define BONE_CAPEMGR_PM_OPS NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver bone_capemgr_driver = {
+	.probe		= bone_capemgr_probe,
+	.remove		= bone_capemgr_remove,
+	.driver		= {
+		.name	= "bone-capemgr",
+		.owner	= THIS_MODULE,
+		.pm	= BONE_CAPEMGR_PM_OPS,
+		.of_match_table = of_match_ptr(bone_capemgr_of_match),
+	},
+};
+
+module_platform_driver(bone_capemgr_driver);
+
+MODULE_AUTHOR("Pantelis Antoniou");
+MODULE_DESCRIPTION("Beaglebone cape manager");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bone_capemgr");
-- 
1.8.5.1

